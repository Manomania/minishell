This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-19T17:18:09.539Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
include/
  debug.h
  error.h
  memory.h
  minishell.h
  validation.h
libft/
  include/
    libft.h
  src/
    ft_atoi.c
    ft_bzero.c
    ft_calloc.c
    ft_isalnum.c
    ft_isalpha.c
    ft_isascii.c
    ft_isdigit.c
    ft_isprint.c
    ft_itoa.c
    ft_lstadd_back.c
    ft_lstadd_front.c
    ft_lstclear.c
    ft_lstdelone.c
    ft_lstiter.c
    ft_lstlast.c
    ft_lstmap.c
    ft_lstnew.c
    ft_lstsize.c
    ft_memchr.c
    ft_memcmp.c
    ft_memcpy.c
    ft_memmove.c
    ft_memset.c
    ft_printf.c
    ft_putchar_fd.c
    ft_putendl_fd.c
    ft_putnbr_fd.c
    ft_putstr_fd.c
    ft_split.c
    ft_strchr.c
    ft_strdup.c
    ft_striteri.c
    ft_strjoin.c
    ft_strlcat.c
    ft_strlcpy.c
    ft_strlen.c
    ft_strmapi.c
    ft_strncmp.c
    ft_strnstr.c
    ft_strrchr.c
    ft_strtrim.c
    ft_substr.c
    ft_tolower.c
    ft_toupper.c
    get_next_line_utils.c
    get_next_line.c
    parsing.c
    print_adress.c
    print_char.c
    print_hexa.c
    print_int.c
  .git
  Makefile
src/
  builtins/
    builtins_try.c
  command/
    command_add.c
    command_bin.c
    command_execute_utils.c
    command_execute.c
    command_new.c
    command_parse.c
    command_redirections.c
  debug/
    debug_utils.c
    debug.c
  env/
    env_find_bin.c
    env_find.c
    env_quotes.c
    env.c
  error/
    ctx_error_exit.c
    error_utils.c
    error.c
  exec/
    exec_cmdas_utils.c
    exec_cmdas_utils2.c
    exec_cmdas.c
  free/
    ctx_exit.c
    free_2d_array.c
    free_command.c
    free_ctx.c
    free_env.c
    pipes_utils.c
  init/
    init_ctx.c
    init_parse.c
  lexer/
    lexer_read_utils.c
    lexer_read.c
    lexer_token_is.c
    lexer_token_utils.c
    lexer_token.c
    lexer_tokenize.c
    lexer_utils.c
  memory/
    memory.c
  parser/
    parser_command.c
    parser_pipeline.c
    parser_utils.c
  path/
    bin_find_path.c
    bin_find.c
  redir/
    heredoc.c
    redirections.c
  signals/
    signals.c
  test/
    main.c
  validation/
    validation.c
  main_utils.c
  main.c
.editorconfig
.gitignore
.gitmodules
files.mk
Makefile
readline.supp
README.md
test_adv.sh
test.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="include/debug.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:36:58 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:37:03 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef DEBUG_H
# define DEBUG_H

# include "minishell.h"

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define DEBUG_NONE 0
# define DEBUG_ERROR 1
# define DEBUG_INFO 2
# define DEBUG_VERBOSE 3

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// global variable
extern int	g_debug_level;

// debug.c
void	debug_init(int level);
void	debug_print_token(int level, t_token *token);
void	debug_print_tokens(int level, t_token *tokens);
void	debug_print_command(int level, t_command *cmd);
void	debug_print_commands(int level, t_command *cmd);
void	debug_log(int level, const char *module, const char *msg);

#endif
</file>

<file path="include/error.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:32:19 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:45:16 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ERROR_H
# define ERROR_H

# include "minishell.h"

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

typedef enum e_error_level
{
	INFO,
	WARNING,
	ERROR,
	FATAL
}	t_error_level;

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// ctx_error_exit.c
void			ctx_error_exit(t_ctx *ctx, t_error_type err);

// error.c
int				error_code(t_error_type err);
void			error_print(t_error_level level, const char *module, const char *msg);

// error_utils.c
t_error_info	*get_error_table(void);
int				ctx_error(t_error_type err);
int				ctx_error_level(t_error_type err, t_error_level level);
void			error_exit(t_ctx *ctx, t_error_type err, const char *module);

#endif
</file>

<file path="include/memory.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:33:40 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:33:44 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MEMORY_H
# define MEMORY_H

# include "minishell.h"

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// memory.c
char	*safe_strdup(t_ctx *ctx, const char *str, const char *module);
char	*safe_strjoin(t_ctx *ctx, const char *s1, const char *s2,
			const char *module);
void	*safe_malloc(t_ctx *ctx, size_t size, const char *module);
void	*safe_calloc(t_ctx *ctx, size_t nmemb, size_t size, const char *module);

#endif
</file>

<file path="include/minishell.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 17:15:54 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 17:02:24 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft.h"
# include <errno.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define RESET "\033[039m"
# define RED "\033[091m"
# define BLUE "\033[034m"
# define GREEN "\033[092m"
# define YELLOW "\033[093m"
# define MAGENTA "\033[35m"
# define CYAN "\033[36m"

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

typedef enum e_bool
{
	false,
	true,
}							t_bool;

typedef enum e_token_type
{
	TOK_WORD,          // Commands, args, filename
	TOK_OPEN_PAR,      // (
	TOK_CLOSE_PAR,     // )
	TOK_REDIR_FROM,    // <
	TOK_REDIR_TO,      // >
	TOK_HERE_DOC_FROM, // <<
	TOK_HERE_DOC_TO,   // >>
	TOK_PIPE,          // |
	TOK_ENV,           // $
	TOK_AND,           // &&
	TOK_OR,            // ||
	TOK_NEW_LINE,      // \n
	TOK_EOF,           // '\0'
}							t_token_type;

typedef struct s_token
{
	t_token_type			type;
	struct s_token			*next;
	char					*value;
}							t_token;

typedef struct s_lexer
{
	char					*input;
	int						position;
	int						length;
}							t_lexer;

/**
 * @brief Represents a command redirection (input/output)
 */
typedef struct s_redirection
{
	t_token_type			type;
	struct s_redirection	*next;
	int						fd;
	char					*filename;
}							t_redirection;

/**
 * @brief Represents a single command with its arguments and redirections
 */
typedef struct s_command
{
	t_token_type			operator;
	t_redirection			*redirection;
	struct s_command		*next;
	char					**args;
	int						arg_count;
}							t_command;

typedef struct s_parse
{
	t_token					*token;
	t_token					*current;
}							t_parse;

typedef struct s_env
{
	struct s_env			*next;
	char					*key;
	char					*value;
}							t_env;

typedef enum e_error_type
{
	ERR_NONE = 0,
	ERR_CMD_NOT_FOUND,
	ERR_NO_PERMISSION,
	ERR_IO_ERROR,
	ERR_UNIMPLEMENTED,
	ERR_ALLOC,
	ERR_PIPE,
	ERR_CHILD,
	ERR_NO_SUCH_FILE,
}							t_error_type;

typedef struct s_error_info
{
	int						code;
	const char				*message;
	t_bool					use_perror;
}							t_error_info;

/**
 * @brief Represents a parsed token
 */
typedef struct s_ctx
{
	t_env					*env_list;
	int						exit_status;
	int						interactive;
	int						argc;
	char					**argv;
	char					**envp;
	t_token					*tokens;
	t_command				*cmd;
	int						fd_file_in;
	int						fd_file_out;
}							t_ctx;

typedef struct s_quote_state
{
	int						in_single_quote;
	int						in_double_quote;
}							t_quote_state;

/**
 * @brief Structure to hold pipeline process data
 */
typedef struct s_pipe_data
{
	t_command				*current;
	int						cmd_count;
	int						i;
	int						prev_pipe;
	pid_t					*pids;
	int						pipe_fds[2];
}							t_pipe_data;

/**
 * @brief Simple enum proper error handling in bin_find.c
 */
typedef enum e_path_error
{
	PATH_ERR_NONE,
	PATH_ERR_NOT_FOUND,
	PATH_ERR_NO_PERMISSION,
	PATH_ERR_OTHER
}							t_path_error;

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// builtins_try.c
t_bool						builtins_try(t_ctx *ctx, t_command *cmd);

// command_add.c
int							command_add_argument(t_command *cmd, char *arg);
int							command_add_redirection(t_command *cmd,
								t_token_type type, int fd, char *filename);

// command_bin.c
t_bool						command_bin(t_ctx *ctx);

// command_execute.c
int							command_execute(t_ctx *ctx);

// command_execute_utils.c
int							get_exit_status(int status);
void						execute_child(t_ctx *ctx);

// command_new.c
t_command					*command_new(void);

// command_parse.c
t_command					*command_parse(t_ctx *ctx, t_token *tokens);

// command_redirection.c
int							handle_redirections(t_redirection *redirections);

// debug_utils.c
void						print_tokens(t_token *tokens);

// env.c
char						*expand_var(t_ctx *ctx, char *var_name);
char						*append_part(char *result, char *str, int start,
								int end);
char						*expand_variable(t_ctx *ctx, char *str, int *i,
								int in_squote);

// env_find.c
char						*env_find(t_ctx *ctx, char *var);

// env_find_bin.c
char						*env_find_bin(t_ctx *ctx, char *bin);

// env_quotes
char						*handle_quotes_and_vars(t_ctx *ctx, char *str);

// exec_cmdas.c
t_bool						exec_cmdas(t_ctx *ctx);

// exec_cmdas_utils.c
pid_t						exec_piped_command(t_ctx *ctx, t_command *cmd,
								int input_fd, int output_fd);
int							setup_pipe(int pipe_fds[2]);
int							wait_for_pids(pid_t *pids, int count);

// exec_cmdas_utils2.c
int							count_commands(t_command *cmd);
void						setup_child_process(t_ctx *ctx, t_command *cmd,
								int input_fd, int output_fd);

// ctx_exit.c
void						ctx_exit(t_ctx *ctx);

// free_2d_array.c
void						free_2d_array(void **ptrs);

// free_commands.c
void						free_command(t_command *cmd);
void						free_all_commands(t_command *cmd);

// free_ctx.c
void						ctx_clear(t_ctx *ctx);

// free_env.c
void						free_env_list(t_env *env_list);
int							parse_env_var(char *env_str, t_env **env_list);

// init_ctx.c
t_ctx						*init_ctx(int argc, char **argv, char **envp);
int							add_env_var(t_env **env_list, char *key,
								char *value);

// init_parse.c
t_command					*create_command(void);
t_token						*create_token(t_token_type type, char *value);
t_redirection				*create_redirection(t_token_type type,
								char *filename);
void						init_parse_context(t_parse *parse, t_token *token);

// lexer_read.c
char						*read_word_lexer(t_lexer *lexer);
char						*read_complex_word(t_lexer *lexer);
char						*read_quoted_string_lexer(t_lexer *lexer,
								char quote_char);

// lexer_read_utils.c
char						*join_and_free(char *s1, char *s2);
char						*handle_dollar_sign(char *result);
char						*handle_word_part(t_lexer *lexer, char *result);
char						*handle_quoted_part(t_lexer *lexer, char *result,
								char quote_char);

// lexer_token.c
t_token						*next_token_lexer(t_lexer *lexer);
void						free_all_token(t_token *token);

// lexer_token_is.c
t_bool						token_is_redirection(t_token_type type);

// lexer_token_utils.c
t_token						*handle_basics_token(t_lexer *lexer);
t_token						*handle_pipe_and_token(t_lexer *lexer);
t_token						*handle_redir_from_and_to_token(t_lexer *lexer);
t_token						*handle_env_token(t_lexer *lexer);

// lexer_tokenize.c
t_token						*tokenize(t_ctx *ctx, char *input);

// lexer_utils.c
char						get_lexer(t_lexer *lexer);
void						advance_lexer(t_lexer *lexer);
void						skip_whitespace_lexer(t_lexer *lexer);

// parser_utils.c
char						*get_token_value(t_parse *parse);
int							check_parse(t_parse *parse, t_token_type type);
int							consume_parse(t_parse *parse, t_token_type type);
int							check_token_type(t_parse *parse, t_token_type type);
void						advance_parse(t_parse *parse);

// bin_find.c
char						*bin_find(t_ctx *ctx, char *bin);

// bin_find_path.c
char						*bin_find_path(const char *dir, char *bin);

// heredoc.c
int							setup_heredocs(t_ctx *ctx, t_command *cmd);

// redirections.c
int							setup_redirections(t_redirection *redirections);

// signals.c
void						setup_signals(void);
void						reset_signals(void);
void						setup_parent_signals(void);

// main.c
// A REMPLIR

// main_utils.c
char						*get_user_input(t_ctx *ctx, int prev_status);

// A REMPLACER EN FONCTION SI TU UTILISES MES FONCTIONS
// // parser_command.c
t_command					*parse_command(t_parse *parse, t_ctx *ctx);
// int				parse_redirection(t_parse *parse, t_command *cmd,
// 					t_ctx *ctx);
// void			add_redirection(t_command *cmd, t_redirection *redirection);
//
// // parser_pipeline.c
// t_command		*parse_pipeline(t_ctx *ctx, t_parse *parse);
// t_command		*parse_command_sequence(t_ctx *ctx, t_parse *parse);

#endif
</file>

<file path="include/validation.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.h                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:39:18 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:39:19 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef VALIDATION_H
# define VALIDATION_H

# include "minishell.h"

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define MAX_INPUT_LEN		4096
# define MAX_VAR_NAME_LEN	255

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

t_bool	validate_command(t_command *cmd, t_ctx *ctx);
t_bool	validate_env_var_name(char *name, t_ctx *ctx);
t_bool	validate_filename(char *filename, t_ctx *ctx);
t_bool	validate_input_length(char *input, t_ctx *ctx);

#endif
</file>

<file path="libft/include/libft.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2025/03/17 14:40:07 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 1
# endif

# ifndef OPEN_MAX
#  define OPEN_MAX 1024
# endif

# include <fcntl.h>
# include <stdarg.h>
# include <stdint.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;

typedef struct s_format
{
	char			conversion;
}					t_format;

int					ft_putnbr(int n);
int					ft_toupper(int c);
int					ft_tolower(int c);
int					ft_isprint(int c);
int					ft_isdigit(int c);
int					ft_isascii(int c);
int					ft_isalpha(int c);
int					ft_isalnum(int c);
int					ft_handle_int(int n);
int					ft_handle_char(int c);
int					ft_handle_percent(void);
int					ft_lstsize(t_list *lst);
int					ft_putchar(const char c);
int					ft_atoi(const char *str);
int					ft_check_line(char *str);
int					ft_putstr(const char *str);
int					ft_putptr(unsigned long ptr);
int					ft_handle_str(const char *str);
int					ft_printmemory(unsigned long n);
int					ft_handle_ptr(unsigned long ptr);
int					ft_printf(const char *format, ...);
int					ft_putnbr_unsigned(unsigned int n);
int					ft_puthexa(unsigned int n, int upper);
int					ft_handle_nbr_unsigned(unsigned int n);
int					ft_check_args(t_format fmt, va_list args);
int					ft_handle_hexa(unsigned int n, t_format fmt);
int					ft_memcmp(const void *s1, const void *s2, size_t n);
int					ft_strncmp(const char *s1, const char *s2, size_t n);

size_t				ft_strlen(const char *s);
size_t				count_words(const char *s, char c);
size_t				ft_strlcpy(char *dest, const char *src, size_t size);
size_t				ft_strlcat(char *dest, const char *src, size_t size);

char				*ft_itoa(int n);
char				*get_next_line(int fd);
char				*ft_strdup(const char *s);
char				*my_strdup(const char *s);
char				*my_strjoin(char *s1, char *s2);
char				*ft_strchr(const char *s, int c);
char				**ft_split(char const *s, char c);
char				*ft_strrchr(const char *s, int c);
char				*ft_strjoin(char const *s1, char const *s2);
char				*ft_strtrim(char const *s1, char const *set);
char				*ft_strmapi(char const *s, char (*f)(unsigned int, char));
char				*ft_substr(char const *s, unsigned int start, size_t len);
char				*ft_strnstr(const char *big, const char *little,
						size_t len);

void				ft_bzero(void *s, size_t n);
void				ft_putnbr_fd(int n, int fd);
void				ft_putchar_fd(char c, int fd);
void				ft_putstr_fd(char *s, int fd);
void				ft_putendl_fd(char *s, int fd);
void				free_words(char **words, size_t i);
void				*ft_calloc(size_t nmemb, size_t size);
void				ft_lstadd_back(t_list **lst, t_list *new);
void				*ft_memchr(const void *s, int c, size_t n);
void				*ft_memchr(const void *s, int c, size_t n);
void				*ft_memset(void *adr, int value, size_t n);
void				ft_lstadd_front(t_list **lst, t_list *new);
void				ft_lstiter(t_list *lst, void (*f)(void *));
void				ft_lstdelone(t_list *lst, void (*del)(void *));
void				ft_lstclear(t_list **lst, void (*del)(void *));
void				parse_format(const char **format, t_format *fmt);
void				*ft_memcpy(void *dest, const void *src, size_t n);
void				*ft_memmove(void *dest, const void *src, size_t n);
void				ft_striteri(char *s, void (*f)(unsigned int, char *));

t_list				*ft_lstlast(t_list *lst);
t_list				*ft_lstnew(void *content);
t_list				*ft_lstmap(t_list *lst, void *(*f)(void *),
						void (*del)(void *));

#endif
</file>

<file path="libft/src/ft_atoi.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 16:38:11 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_atoi(const char *str)
{
	int			i;
	int			sign;
	long int	result;

	i = 0;
	sign = 1;
	result = 0;
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
		i++;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign *= -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		result = (result * 10) + (str[i] - '0');
		i++;
	}
	return (result * sign);
}
</file>

<file path="libft/src/ft_bzero.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_bzero(void *s, size_t n)
{
	size_t	i;
	char	*ptr;

	i = 0;
	ptr = (char *)s;
	while (i < n)
	{
		ptr[i] = 0;
		i++;
	}
}
</file>

<file path="libft/src/ft_calloc.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;
	size_t	total_size;

	total_size = nmemb * size;
	if (nmemb > SIZE_MAX / size || size > SIZE_MAX / nmemb)
		return (NULL);
	ptr = malloc(total_size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, total_size);
	return (ptr);
}
</file>

<file path="libft/src/ft_isalnum.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_isalnum(int c)
{
	if (ft_isalpha(c) || ft_isdigit(c))
		return (1);
	return (0);
}
</file>

<file path="libft/src/ft_isalpha.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	return (0);
}
</file>

<file path="libft/src/ft_isascii.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	return (0);
}
</file>

<file path="libft/src/ft_isdigit.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 16:45:03 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}
</file>

<file path="libft/src/ft_isprint.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	return (0);
}
</file>

<file path="libft/src/ft_itoa.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

static int	num_len(long n)
{
	int		len;

	len = 1;
	if (n < 0)
	{
		n = -n;
		len++;
	}
	while (n >= 10)
	{
		n /= 10;
		len++;
	}
	return (len);
}

char	*ft_itoa(int n)
{
	int			len;
	long int	nb;
	char		*result;

	nb = n;
	len = num_len(nb);
	result = (char *)malloc(sizeof(char) * (len + 1));
	if (!result)
		return (NULL);
	result[len] = '\0';
	if (nb < 0)
	{
		result[0] = '-';
		nb = -nb;
	}
	while (nb > 0)
	{
		result[len - 1] = ((nb % 10) + '0');
		nb /= 10;
		len--;
	}
	if (n == 0)
		result[0] = '0';
	return (result);
}
</file>

<file path="libft/src/ft_lstadd_back.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	if (lst)
	{
		if (*lst == NULL)
			*lst = new;
		else
			ft_lstlast(*lst)->next = new;
	}
}
</file>

<file path="libft/src/ft_lstadd_front.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new->next = *lst;
	*lst = new;
}
</file>

<file path="libft/src/ft_lstclear.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void*))
{
	t_list	*new;

	while (*lst)
	{
		new = (*lst)->next;
		del((*lst)->content);
		free(*lst);
		*lst = new;
	}
	*lst = NULL;
}
</file>

<file path="libft/src/ft_lstdelone.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void *))
{
	if (!lst || !del)
		return ;
	del(lst->content);
	free(lst);
}
</file>

<file path="libft/src/ft_lstiter.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	while (lst)
	{
		f(lst->content);
		lst = lst->next;
	}
}
</file>

<file path="libft/src/ft_lstlast.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (lst)
	{
		while (lst->next)
			lst = lst->next;
	}
	return (lst);
}
</file>

<file path="libft/src/ft_lstmap.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*modified_lst;
	t_list	*modified_new;
	void	*new_content;

	modified_lst = NULL;
	while (lst)
	{
		new_content = f(lst->content);
		if (!new_content)
		{
			ft_lstclear(&modified_lst, del);
			return (NULL);
		}
		modified_new = ft_lstnew(new_content);
		if (!modified_new)
		{
			del(new_content);
			ft_lstclear(&modified_lst, del);
			return (NULL);
		}
		ft_lstadd_back(&modified_lst, modified_new);
		lst = lst->next;
	}
	return (modified_lst);
}
</file>

<file path="libft/src/ft_lstnew.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new;

	new = malloc(sizeof(t_list));
	if (!new)
		return (NULL);
	new->content = content;
	new->next = NULL;
	return (new);
}
</file>

<file path="libft/src/ft_lstsize.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_lstsize(t_list *lst)
{
	size_t	i;

	i = 0;
	while (lst)
	{
		i++;
		lst = lst->next;
	}
	return (i);
}
</file>

<file path="libft/src/ft_memchr.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	unsigned const char	*found;

	found = (unsigned const char *)s;
	while (n)
	{
		if (*found == (unsigned char)c)
			return ((void *)found);
		found++;
		n--;
	}
	return (NULL);
}
</file>

<file path="libft/src/ft_memcmp.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	unsigned char	*c1;
	unsigned char	*c2;

	if (n == 0)
		return (0);
	c1 = (unsigned char *)s1;
	c2 = (unsigned char *)s2;
	while (n)
	{
		if (*c1 != *c2)
			return (*c1 - *c2);
		n--;
		c1++;
		c2++;
	}
	return (0);
}
</file>

<file path="libft/src/ft_memcpy.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	size_t					i;
	unsigned char			*dest_data;
	unsigned const char		*src_data;

	if (!dest && !src)
		return (NULL);
	i = 0;
	dest_data = (unsigned char *)dest;
	src_data = (unsigned const char *)src;
	while (i < n)
	{
		dest_data[i] = src_data[i];
		i++;
	}
	return (dest_data);
}
</file>

<file path="libft/src/ft_memmove.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 16:47:31 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char		*dest_data;
	unsigned const char	*src_data;

	if (!dest && !src)
		return (NULL);
	if (src > dest)
		dest = ft_memcpy(dest, src, n);
	else
	{
		dest_data = (unsigned char *)dest;
		src_data = (unsigned const char *)src;
		while (n > 0)
		{
			n--;
			dest_data[n] = src_data[n];
		}
	}
	return (dest);
}
</file>

<file path="libft/src/ft_memset.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	*ft_memset(void *adr, int value, size_t n)
{
	char	*str;

	str = (char *)adr;
	while (n)
	{
		*str = value;
		str++;
		n--;
	}
	return (adr);
}
</file>

<file path="libft/src/ft_printf.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libftprintf.h.c                                      :+:      :+:    :+: */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 18:04:46 by maximart          #+#    #+#             */
/*   Updated: 2024/11/05 09:42:18 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_check_args(t_format fmt, va_list args)
{
	if (fmt.conversion == 'c')
		return (ft_handle_char(va_arg(args, int)));
	else if (fmt.conversion == 's')
		return (ft_handle_str(va_arg(args, char *)));
	else if (fmt.conversion == 'p')
		return (ft_handle_ptr(va_arg(args, unsigned long)));
	else if (fmt.conversion == 'd' || fmt.conversion == 'i')
		return (ft_handle_int(va_arg(args, int)));
	else if (fmt.conversion == 'u')
		return (ft_handle_nbr_unsigned(va_arg(args, unsigned int)));
	else if (fmt.conversion == 'x' || fmt.conversion == 'X')
		return (ft_handle_hexa(va_arg(args, unsigned int), fmt));
	else if (fmt.conversion == '%')
		return (ft_handle_percent());
	return (0);
}

int	ft_printf(const char *format, ...)
{
	int			count;
	va_list		args;
	t_format	fmt;

	count = 0;
	va_start(args, format);
	while (*format)
	{
		if (*format == '%' && *(format + 1))
		{
			format++;
			parse_format(&format, &fmt);
			count += ft_check_args(fmt, args);
		}
		else
			count += ft_putchar(*format);
		format++;
	}
	va_end(args);
	return (count);
}
</file>

<file path="libft/src/ft_putchar_fd.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}
</file>

<file path="libft/src/ft_putendl_fd.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	write(fd, s, ft_strlen(s));
	write(fd, "\n", 1);
}
</file>

<file path="libft/src/ft_putnbr_fd.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	char	num;

	if (n == -2147483648)
	{
		write (fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		write (fd, "-", 1);
		n = -n;
	}
	if (n > 9)
		ft_putnbr_fd((n / 10), fd);
	num = (n % 10) + '0';
	write (fd, &num, 1);
}
</file>

<file path="libft/src/ft_putstr_fd.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	write(fd, s, ft_strlen(s));
}
</file>

<file path="libft/src/ft_split.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

size_t	count_words(const char *s, char c)
{
	size_t	count;
	int		in_word;

	count = 0;
	in_word = 0;
	while (*s)
	{
		if (*s != c && in_word == 0)
		{
			in_word = 1;
			count++;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (count);
}

static char	*malloc_word(const char *s, size_t start, size_t end)
{
	char	*word;
	size_t	i;

	word = ft_calloc(sizeof(char), (end - start + 1));
	if (!word)
		return (NULL);
	i = 0;
	while (start < end)
		word[i++] = s[start++];
	return (word);
}

void	free_words(char **words, size_t i)
{
	while (i > 0)
		free(words[--i]);
	free(words);
}

static char	**ft_fill_split(char const *s, char c, char **split, size_t word_c)
{
	size_t	i;
	size_t	j;
	size_t	start;

	i = 0;
	j = 0;
	while (s[i] && j < word_c)
	{
		while (s[i] && s[i] == c)
			i++;
		start = i;
		while (s[i] && s[i] != c)
			i++;
		if (i > start)
		{
			split[j] = malloc_word(s, start, i);
			if (!split[j++])
				return (free_words(split, j), NULL);
		}
	}
	split[j] = NULL;
	return (split);
}

char	**ft_split(char const *s, char c)
{
	char	**split;
	size_t	words_count;

	if (!s)
		return (NULL);
	words_count = count_words(s, c);
	split = (char **)ft_calloc(sizeof(char *), (words_count + 1));
	if (!split)
		return (NULL);
	return (ft_fill_split(s, c, split, words_count));
}
</file>

<file path="libft/src/ft_strchr.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (char )c)
			return ((char *)s);
		s++;
	}
	if (*s == (char)c)
		return ((char *)s);
	return (NULL);
}
</file>

<file path="libft/src/ft_strdup.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strdup(const char *s)
{
	char	*dup;
	int		s_len;

	s_len = ft_strlen(s);
	dup = (char *)malloc(sizeof(char) * (s_len + 1));
	if (!dup)
		return (NULL);
	dup[s_len] = 0;
	while (s_len >= 0)
	{
		dup[s_len] = s[s_len];
		s_len--;
	}
	return (dup);
}
</file>

<file path="libft/src/ft_striteri.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	i = 0;
	if (!s || !f)
		return ;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}
</file>

<file path="libft/src/ft_strjoin.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*join;
	size_t	len_s1;
	size_t	len_s2;

	if (!s1 || !s2)
		return (NULL);
	len_s1 = ft_strlen(s1);
	len_s2 = ft_strlen(s2);
	join = malloc(sizeof(char) * (len_s1 + len_s2 + 1));
	if (!join)
		return (NULL);
	ft_strlcpy(join, s1, len_s1 + 1);
	ft_strlcpy(join + len_s1, s2, len_s2 + 1);
	return (join);
}
</file>

<file path="libft/src/ft_strlcat.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 16:49:44 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

size_t	ft_strlcat(char *dest, const char *src, size_t size)
{
	size_t	src_len;
	size_t	i;

	src_len = ft_strlen(dest);
	i = 0;
	while (size <= src_len)
		return (ft_strlen(src) + size);
	while (src[i] && (src_len + i) < (size - 1))
	{
		dest[src_len + i] = src[i];
		i++;
	}
	dest[src_len + i] = '\0';
	return (ft_strlen(src) + src_len);
}
</file>

<file path="libft/src/ft_strlcpy.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

size_t	ft_strlcpy(char *dest, const char *src, size_t size)
{
	size_t	i;

	if (size == 0)
		return (ft_strlen(src));
	i = 0;
	while (src[i] && i < (size - 1))
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (ft_strlen(src));
}
</file>

<file path="libft/src/ft_strlen.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

size_t	ft_strlen(const char *str)
{
	size_t	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}
</file>

<file path="libft/src/ft_strmapi.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char	*result;
	size_t	i;

	if (!s || !f)
		return (NULL);
	result = (char *)malloc(sizeof(char) * (ft_strlen(s) + 1));
	if (!result)
		return (NULL);
	i = 0;
	while (s[i])
	{
		result[i] = f(i, s[i]);
		i++;
	}
	result[i] = '\0';
	return (result);
}
</file>

<file path="libft/src/ft_strncmp.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && (s1[i] || s2[i]))
	{
		if ((unsigned char)s1[i] != (unsigned char)s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}
</file>

<file path="libft/src/ft_strnstr.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;
	size_t	length;

	if (!little[0])
		return ((char *)big);
	i = 0;
	length = ft_strlen(little);
	while (big[i] && (i + length - 1) < len)
	{
		j = 0;
		while (little[j] && big[i + j] == little[j])
		{
			if (j == length - 1)
				return ((char *)(big + i));
			j++;
		}
		i++;
	}
	return (0);
}
</file>

<file path="libft/src/ft_strrchr.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_strrchr(const char *s, int c)
{
	char	*last_occur;

	last_occur = 0;
	while (*s)
	{
		if (*s == (char)c)
			last_occur = (char *)s;
		s++;
	}
	if (*s == (char)c)
		return ((char *)s);
	return (last_occur);
}
</file>

<file path="libft/src/ft_strtrim.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

static int	is_in_set(char c, char const *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	char	*trim;
	size_t	start;
	size_t	end;

	if (!s1 || !set)
		return (NULL);
	start = 0;
	while (s1[start] && is_in_set(s1[start], set))
		start++;
	end = ft_strlen(s1);
	while (end > start && is_in_set(s1[end - 1], set))
		end--;
	trim = malloc(sizeof(char) * (end - start + 1));
	if (!trim)
		return (NULL);
	ft_strlcpy(trim, &s1[start], end - start + 1);
	return (trim);
}
</file>

<file path="libft/src/ft_substr.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*substr;

	if (!s)
		return (NULL);
	if (start >= ft_strlen(s))
		return (ft_strdup(""));
	if (len > ft_strlen(s) - start)
		len = ft_strlen(s) - start;
	substr = malloc(sizeof(char) * (len + 1));
	if (!substr)
		return (NULL);
	ft_strlcpy(substr, s + start, len + 1);
	return (substr);
}
</file>

<file path="libft/src/ft_tolower.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 13:43:35 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		return (c + 32);
	return (c);
}
</file>

<file path="libft/src/ft_toupper.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 14:51:48 by maximart          #+#    #+#             */
/*   Updated: 2024/11/04 16:51:42 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		return (c - 32);
	return (c);
}
</file>

<file path="libft/src/get_next_line_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/20 16:28:45 by maximart          #+#    #+#             */
/*   Updated: 2024/11/20 16:28:49 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_check_line(char	*str)
{
	size_t	i;

	i = 0;
	if (ft_strlen(str + i) == 0)
		return (0);
	while (str[i])
	{
		if (str[i] == '\n')
			return (1);
		i++;
	}
	return (0);
}

char	*my_strjoin(char *s1, char *s2)
{
	char	*join;
	size_t	len_s1;
	size_t	len_s2;

	if (!s1 && !s2)
		return (NULL);
	len_s1 = ft_strlen(s1);
	len_s2 = 0;
	while (s2[len_s2] != '\n' && s2[len_s2] != 0)
		len_s2++;
	if (s2[len_s2] == '\n')
		len_s2++;
	join = malloc(len_s1 + len_s2 + 1);
	if (!join)
		return (free(s1), NULL);
	if (s1)
		ft_strlcpy(join, s1, len_s1 + 1);
	if (s2)
		ft_strlcpy(join + len_s1, s2, len_s2 + 1);
	free(s1);
	return (join);
}

char	*my_strdup(const char *s)
{
	char	*dup;
	size_t	s_len;
	size_t	i;

	s_len = 0;
	while (s[s_len] != '\n' && s[s_len] != 0)
		s_len++;
	if (s[s_len] == '\n')
		s_len++;
	dup = (char *)malloc(sizeof(char) * (s_len + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (i < s_len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = 0;
	return (dup);
}
</file>

<file path="libft/src/get_next_line.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/20 16:29:01 by maximart          #+#    #+#             */
/*   Updated: 2024/11/20 16:30:31 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

static void	my_bzero(char *str)
{
	size_t	i;

	i = 0;
	while (str[i] != 0)
	{
		str[i] = 0;
		i++;
	}
}

static void	ft_clean(char *str)
{
	size_t	i;
	size_t	j;

	i = 0;
	while (str[i] != '\n' && str[i] != 0)
		i++;
	if (str[i] == '\n')
		i++;
	j = 0;
	while (str[i + j])
	{
		str[j] = str[i + j];
		j++;
	}
	str[j] = 0;
}

static char	*ft_rd(int fd, int rd, char *ln, char bf[OPEN_MAX][BUFFER_SIZE + 1])
{
	while (rd && ft_check_line(ln) == 0)
	{
		rd = read(fd, bf[fd], BUFFER_SIZE);
		if (rd < 0)
			return (my_bzero(bf[fd]), free(ln), NULL);
		bf[fd][rd] = 0;
		ln = my_strjoin(ln, bf[fd]);
		if (!ln)
			return (NULL);
	}
	return (ln);
}

char	*get_next_line(int fd)
{
	static char	buffer[OPEN_MAX][BUFFER_SIZE + 1];
	char		*line;
	int			read_byte;

	read_byte = 1;
	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	line = my_strdup(buffer[fd]);
	if (!line)
		return (NULL);
	line = ft_rd(fd, read_byte, line, buffer);
	if (!line)
		return (NULL);
	ft_clean(buffer[fd]);
	if (line[0] == 0)
		return (free(line), NULL);
	return (line);
}
</file>

<file path="libft/src/parsing.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bonus.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/14 09:59:33 by maximart          #+#    #+#             */
/*   Updated: 2024/11/14 09:59:40 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

void	parse_format(const char **format, t_format *fmt)
{
	fmt->conversion = **format;
}
</file>

<file path="libft/src/print_adress.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/13 14:16:35 by maximart          #+#    #+#             */
/*   Updated: 2024/11/13 14:17:39 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_printmemory(unsigned long n)
{
	int			count;
	const char	*base;

	base = "0123456789abcdef";
	count = 0;
	if (n >= 16)
		count += ft_printmemory(n / 16);
	count += ft_putchar(base[n % 16]);
	return (count);
}

int	ft_putptr(unsigned long ptr)
{
	int	count;

	count = 0;
	if (!ptr)
		return (ft_putstr("(nil)"));
	count += ft_putstr("0x");
	count += ft_printmemory(ptr);
	return (count);
}

int	ft_handle_ptr(unsigned long ptr)
{
	return (ft_putptr(ptr));
}
</file>

<file path="libft/src/print_char.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   miscellaneous.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/14 10:26:51 by maximart          #+#    #+#             */
/*   Updated: 2024/11/14 10:27:06 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_putchar(const char c)
{
	return ((int)write(1, &c, 1));
}

int	ft_handle_char(int c)
{
	return (ft_putchar(c));
}

int	ft_handle_percent(void)
{
	return (ft_putchar('%'));
}

int	ft_putstr(const char *str)
{
	int	count;

	count = 0;
	if (!str)
		return (ft_putstr("(null)"));
	while (*str)
		count += ft_putchar(*str++);
	return (count);
}

int	ft_handle_str(const char *str)
{
	return (ft_putstr(str));
}
</file>

<file path="libft/src/print_hexa.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 13:27:39 by maximart          #+#    #+#             */
/*   Updated: 2024/11/11 13:27:42 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_puthexa(unsigned int n, int upper)
{
	int			count;
	const char	*base;

	if (upper)
		base = "0123456789abcdef";
	else
		base = "0123456789ABCDEF";
	count = 0;
	if (n >= 16)
		count += ft_puthexa(n / 16, upper);
	count += ft_putchar(base[n % 16]);
	return (count);
}

int	ft_handle_hexa(unsigned int n, t_format fmt)
{
	int	count;

	count = 0;
	if (fmt.conversion == 'x')
		count += ft_puthexa(n, 1);
	else if (fmt.conversion == 'X')
		count += ft_puthexa(n, 0);
	return (count);
}
</file>

<file path="libft/src/print_int.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_int.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/14 10:20:22 by maximart          #+#    #+#             */
/*   Updated: 2024/11/14 10:20:25 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/libft.h"

int	ft_putnbr(int n)
{
	int	count;

	count = 0;
	if (n == -2147483648)
	{
		count += ft_putstr("-2147483648");
		return (count);
	}
	if (n < 0)
	{
		count += ft_putchar('-');
		n = -n;
	}
	if (n > 9)
		count += ft_putnbr(n / 10);
	count += ft_putchar((n % 10) + '0');
	return (count);
}

int	ft_handle_int(int n)
{
	int	count;

	count = 0;
	count += ft_putnbr(n);
	return (count);
}

int	ft_putnbr_unsigned(unsigned int n)
{
	int	count;

	count = 0;
	if (n > 9)
		count += ft_putnbr_unsigned(n / 10);
	count += ft_putchar(n % 10 + '0');
	return (count);
}

int	ft_handle_nbr_unsigned(unsigned int n)
{
	return (ft_putnbr_unsigned(n));
}
</file>

<file path="libft/.git">
gitdir: ../.git/modules/libft
</file>

<file path="libft/Makefile">
########################################################################################################################
#                                                      VARIABLES                                                       #
########################################################################################################################

NAME 				= 	libft.a
CC 					= 	gcc
CFLAGS 				= 	-Wall -Wextra -Werror
AR					=	ar rcs
RM					=	rm -f
SRC_FILES			=	ft_atoi \
						ft_bzero \
						ft_calloc \
						ft_isalnum \
						ft_isalpha \
						ft_isascii \
						ft_isdigit \
						ft_isprint \
						ft_itoa \
						ft_lstadd_back \
						ft_lstadd_front \
						ft_lstclear \
						ft_lstdelone \
						ft_lstiter \
						ft_lstlast \
						ft_lstmap \
						ft_lstnew \
						ft_lstsize \
						ft_memchr \
						ft_memcmp \
						ft_memcpy \
						ft_memmove \
						ft_memset \
						ft_putchar_fd \
						ft_putendl_fd \
						ft_putnbr_fd \
						ft_putstr_fd \
						ft_split \
						ft_strchr \
						ft_strdup \
						ft_striteri \
						ft_strjoin \
						ft_strlcat \
						ft_strlcpy \
						ft_strlen \
						ft_strmapi \
						ft_strncmp \
						ft_strnstr \
						ft_strrchr \
						ft_strtrim \
						ft_substr \
						ft_tolower \
						ft_toupper \
						ft_printf \
						parsing \
						print_adress \
						print_char \
						print_hexa \
						print_int \
						get_next_line \
						get_next_line_utils

LIBFT_SRC 			=	$(addprefix $(SRC_DIR), $(addsuffix .c, $(SRC_FILES)))
OBJ 				= 	$(addprefix $(OBJ_DIR), $(addsuffix .o, $(SRC_FILES)))

HEADERS				=	$(LIBFT_INC)libft.h

########################################################################################################################
#                                                      DIRECTORY                                                       #
########################################################################################################################

SRC_DIR				=	src/
OBJ_DIR				=	obj/
LIBFT_INC			=	include/

########################################################################################################################
#                                                       COMMANDS                                                       #
########################################################################################################################

all:					$(NAME)

$(NAME):				$(OBJ)
							@$(AR) $@ $^

$(OBJ_DIR):
							@mkdir -p $(OBJ_DIR)

$(OBJ_DIR)%.o: 			$(SRC_DIR)%.c $(HEADERS) | $(OBJ_DIR)
							@$(CC) $(CFLAGS) -I$(LIBFT_INC) -c $< -o $@
							$(call PROGRESS_BAR_PERCENTAGE)

########################################################################################################################
#                                                      TARGETS                                                         #
########################################################################################################################

clean:
								@rm -rf $(OBJ_DIR)

fclean: 				clean
								@$(RM) $(NAME)

re: 					fclean all

.PHONY: 				all bonus clean fclean re

########################################################################################################################
#                                                      COLOURS                                                         #
########################################################################################################################

DEF_COLOR			=	\033[0;39m
ORANGE				=	\033[0;33m
GRAY				=	\033[0;90m
RED					=	\033[0;91m
GREEN				=	\033[1;92m
YELLOW				=	\033[1;93m
BLUE				=	\033[0;94m
MAGENTA				=	\033[0;95m
CYAN				=	\033[0;96m
WHITE				=	\033[0;97m

########################################################################################################################
#                                                       DISPLAY                                                        #
########################################################################################################################

SPACEMENT			= -40
COMPILED_SRCS		=	0
FRAMES				=	         
SLEEP_FRAME			=	0.001

SRCS_TO_COMPILE		=	$(shell find $(SRC_DIR) -newer $(NAME) -name '*.c' 2>/dev/null | wc -l)
ifeq ($(SRCS_TO_COMPILE),0)
						SRCS_TO_COMPILE =   $(words $(SRC_FILES))
endif

define PROGRESS_BAR_PERCENTAGE
						$(eval COMPILED_SRCS := $(shell expr $(COMPILED_SRCS) + 1))
						if [ $(COMPILED_SRCS) -eq 1 ]; then \
							printf "$(BLUE)[$(NAME)]:$(DEF_COLOR)\n"; \
						fi
						@percentage=$$(echo "scale=2; $(COMPILED_SRCS) * 100 / $(SRCS_TO_COMPILE)" | bc); \
						for frame in $(FRAMES); do \
							printf "\r$$frame Compiling... [%d/%d] %.2f%%" $(COMPILED_SRCS) $(SRCS_TO_COMPILE) "$$percentage"; \
							sleep $(SLEEP_FRAME); \
						done; \
						if [ $(COMPILED_SRCS) -eq $(SRCS_TO_COMPILE) ]; then \
							printf "%-42b%b" "\r$(GREEN)Compilation finsihed [$(COMPILED_SRCS)/$(SRCS_TO_COMPILE)]" "$(GREEN)[]$(DEF_COLOR)\n\n"; \
						fi
endef
</file>

<file path="src/builtins/builtins_try.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_try.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 12:19:14 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:09:53 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Tries to execute a builtin command
 *
 * @param ctx Context for shell environment
 * @param cmd Command to check for builtin
 * @return t_bool true if builtin was executed, false otherwise
 */
t_bool	builtins_try(t_ctx *ctx, t_command *cmd)
{
	char	cmd_name[64];

	if (!ctx || !cmd || !cmd->args || !cmd->args[0])
	{
		error_print(ERROR, "builtin", "Invalid command");
		return (false);
	}
	ft_strlcpy(cmd_name, "Checking builtin: ", sizeof(cmd_name));
	ft_strlcat(cmd_name, cmd->args[0], sizeof(cmd_name));
	debug_log(DEBUG_INFO, "builtin", cmd_name);
	if (ft_strncmp(cmd->args[0], "exit", __INT_MAX__) == 0)
	{
		debug_log(DEBUG_INFO, "builtin", "Executing exit builtin");
		ctx->exit_status = 1;
		return (true);
	}
	debug_log(DEBUG_INFO, "builtin", "No matching builtin found");
	return (false);
}
</file>

<file path="src/command/command_add.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_add.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:48:41 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:41:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Allocates and copies arguments to a new array
 *
 * @param cmd Command containing the arguments
 * @param new_size Size of the new array to allocate
 * @return char** New array of arguments or NULL on failure
 */
static char	**allocate_args_array(t_command *cmd, int new_size)
{
	char	**new_args;
	int		i;

	new_args = (char **)malloc(sizeof(char *) * (size_t)new_size);
	if (!new_args)
		return (NULL);
	i = 0;
	while (i < cmd->arg_count + 1)
	{
		new_args[i] = cmd->args[i];
		i++;
	}
	new_args[i] = NULL;
	new_args[new_size - 1] = NULL;
	return (new_args);
}

/**
 * @brief Adds an argument to a command
 * Arguments are stored in args array starting at index 1
 * args[0] is always the command name
 *
 * @param cmd Command to add argument to
 * @param arg Argument string to add
 * @return int 0 on success, -1 on failure
 */
int	command_add_argument(t_command *cmd, char *arg)
{
	char	**new_args;
	char	*arg_copy;

	if (!cmd || !arg)
		return (-1);
	new_args = allocate_args_array(cmd, cmd->arg_count + 3);
	if (!new_args)
		return (-1);
	arg_copy = ft_strdup(arg);
	if (!arg_copy)
	{
		free(new_args);
		return (-1);
	}
	new_args[cmd->arg_count + 1] = arg_copy;
	if (cmd->args)
		free(cmd->args);
	cmd->args = new_args;
	cmd->arg_count++;
	return (0);
}

/**
 * @brief Adds a redirection to a command
 *
 * @param cmd Command to add redirection to
 * @param type Redirection type (< > << >>)
 * @param fd File descriptor (0 for input, 1 for output)
 * @param filename Target filename
 * @return int 0 on success, -1 on failure
 */
int	command_add_redirection(t_command *cmd, t_token_type type, int fd,
		char *filename)
{
	t_redirection	*redir;
	t_redirection	*current;

	if (!cmd || !filename)
		return (-1);
	redir = malloc(sizeof(t_redirection));
	if (!redir)
		return (-1);
	redir->type = type;
	redir->fd = fd;
	redir->filename = ft_strdup(filename);
	if (!redir->filename)
		return (free(redir), -1);
	redir->next = NULL;
	if (!cmd->redirection)
		cmd->redirection = redir;
	else
	{
		current = cmd->redirection;
		while (current->next)
			current = current->next;
		current->next = redir;
	}
	return (0);
}
</file>

<file path="src/command/command_bin.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_bin.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 18:52:18 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:25:08 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Finds the binary path and updates the command arg
 *
 * @param ctx Context
 * @return t_bool true if successful, false otherwise
 */
t_bool	command_bin(t_ctx *ctx)
{
	char	*bin_og;
	char	*bin;

	if (!ctx->cmd->args || !ctx->cmd->args[0])
		return (false);
	bin_og = ctx->cmd->args[0];
	bin = bin_find(ctx, bin_og);
	if (!bin)
	{
		free(bin_og);
		ctx->cmd->args[0] = NULL;
		return (false);
	}
	free(bin_og);
	ctx->cmd->args[0] = bin;
	return (true);
}
</file>

<file path="src/command/command_execute_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_execute_utils.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:54:30 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:57:56 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Sets up child process redirections
 *
 * This function handles heredocs and redirections in the child process.
 *
 * @param ctx Context with environment information
 * @param cmd Command containing redirections
 * @return 0 on success, non-zero on error
 */
static int	setup_child_redirections(t_ctx *ctx, t_command *cmd)
{
	int	result;

	result = setup_heredocs(ctx, cmd);
	if (result != 0)
		return (result);
	result = setup_redirections(cmd->redirection);
	return (result);
}

/**
 * @brief Checks if command exists and is executable
 *
 * This function verifies the command path and permissions.
 *
 * @param cmd Command to check
 * @return 0 on success, non-zero on error
 */
static int	check_command_executable(t_command *cmd)
{
	if (!cmd->args[0] || access(cmd->args[0], X_OK) != 0)
	{
		ft_printf("command not found or not executable: %s\n", cmd->args[0]);
		return (1);
	}
	return (0);
}

/**
 * @brief Executes the child process portion of a single command
 *
 * This function handles the execution of a command in a child process.
 *
 * @param ctx Context containing environment and command info
 */
void	execute_child(t_ctx *ctx)
{
	int	redirect_result;
	int	cmd_check;

	reset_signals();
	redirect_result = setup_child_redirections(ctx, ctx->cmd);
	if (redirect_result != 0)
		exit(EXIT_FAILURE);
	cmd_check = check_command_executable(ctx->cmd);
	if (cmd_check != 0)
		exit(EXIT_FAILURE);
	execve(ctx->cmd->args[0], ctx->cmd->args, ctx->envp);
	perror("execve");
	exit(EXIT_FAILURE);
}

/**
 * @brief Gets the exit status from process termination information
 *
 * This function extracts the exit status from the process status.
 *
 * @param status Process status from waitpid
 * @return Exit status of the process
 */
int	get_exit_status(int status)
{
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	if (WIFSIGNALED(status))
		return (128 + WTERMSIG(status));
	return (1);
}
</file>

<file path="src/command/command_execute.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_execute.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 16:10:59 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:16:00 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Executes a single command without a pipeline
 *
 * This function executes a single command by forking a child process.
 *
 * @param ctx Context containing environment and command info
 * @return Exit status of the command
 */
static int	execute_single_command(t_ctx *ctx)
{
	pid_t	pid;
	int		status;

	if (builtins_try(ctx, ctx->cmd))
		return (0);
	if (!command_bin(ctx))
	{
		if (ctx->cmd->args && ctx->cmd->args[0] && (ft_strchr(ctx->cmd->args[0],
					'/') || ctx->cmd->args[0][0] == '.'))
			return (2);
		return (error_code(ERR_CMD_NOT_FOUND));
	}
	setup_parent_signals();
	pid = fork();
	if (pid == -1)
		return (ctx_error(ERR_CHILD));
	if (pid == 0)
		execute_child(ctx);
	waitpid(pid, &status, 0);
	setup_signals();
	return (get_exit_status(status));
}

/**
 * @brief Checks if the command is part of a pipeline
 *
 * This function determines if a command is part of a pipeline.
 *
 * @param cmd Command to check
 * @return true if command is part of pipeline, false otherwise
 */
static t_bool	is_pipeline(t_command *cmd)
{
	return (cmd && cmd->next);
}

/**
 * @brief Executes a command or pipeline
 *
 * @param ctx Context containing environment and command info
 * @return Exit status of the command
 */
int	command_execute(t_ctx *ctx)
{
	if (!ctx || !ctx->cmd)
		return (ctx_error(ERR_ALLOC));
	if (!ctx->cmd->args || !ctx->cmd->args[0])
		return (-1);
	debug_log(DEBUG_INFO, "execute", "Executing command");
	if (is_pipeline(ctx->cmd))
	{
		debug_log(DEBUG_INFO, "execute", "Pipeline detected");
		return (exec_cmdas(ctx));
	}
	return (execute_single_command(ctx));
}
</file>

<file path="src/command/command_new.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_new.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:48:09 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/13 11:47:37 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Creates a new command structure
 *
 * @return t_command* New initialized command or NULL if allocation fails
 */
t_command	*command_new(void)
{
	t_command	*cmd;

	cmd = (t_command *)malloc(sizeof(t_command));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->arg_count = 0;
	cmd->redirection = NULL;
	cmd->next = NULL;
	return (cmd);
}
</file>

<file path="src/command/command_parse.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_parse.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:46:45 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 17:02:35 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Processes a word token during command parsing
 *
 * @param cmd Command structure being built
 * @param token Current token being processed
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_word_token(t_command *cmd, t_token *token, t_ctx *ctx)
{
	char	*expanded_value;

	if (!cmd->args)
	{
		cmd->args = malloc(sizeof(char *) * 2);
		if (!cmd->args)
			return (false);
		expanded_value = handle_quotes_and_vars(ctx, token->value);
		if (!expanded_value)
		{
			free(cmd->args);
			cmd->args = NULL;
			return (false);
		}
		cmd->args[0] = expanded_value;
		cmd->args[1] = NULL;
		cmd->arg_count = 0;
	}
	else
	{
		expanded_value = handle_quotes_and_vars(ctx, token->value);
		if (command_add_argument(cmd, expanded_value) != 0)
		{
			free(expanded_value);
			return (false);
		}
		free(expanded_value);
	}
	return (true);
}

/**
 * @brief Processes an environment variable token during command parsing
 *
 * @param cmd Command structure being built
 * @param token Current token being processed
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_env_token(t_command *cmd, t_token *token, t_ctx *ctx)
{
	char	*expanded_value;

	expanded_value = expand_var(ctx, token->value);
	if (!expanded_value)
		return (false);
	if (!cmd->args)
	{
		cmd->args = malloc(sizeof(char *) * 2);
		if (!cmd->args)
		{
			free(expanded_value);
			return (false);
		}
		cmd->args[0] = expanded_value;
		cmd->args[1] = NULL;
		cmd->arg_count = 0;
	}
	else
	{
		if (command_add_argument(cmd, expanded_value) != 0)
		{
			free(expanded_value);
			return (false);
		}
		free(expanded_value);
	}
	return (true);
}

/**
 * @brief Processes a redirection token during command parsing
 *
 * @param cmd Command to add redirection to
 * @param token Current redirection token
 * @param next_token The next token (containing filename)
 * @param ctx Context containing environment information
 * @return int 0 on success, -1 on failure
 */
static int	handle_redirection_token(t_command *cmd, t_token *token,
		t_token *next_token, t_ctx *ctx)
{
	int		fd;
	int		result;
	char	*expanded_filename;

	if (!cmd || !token || !next_token)
		return (-1);
	if (next_token->type != TOK_WORD && next_token->type != TOK_ENV)
		return (-1);
	fd = 1;
	if (token->type == TOK_REDIR_FROM || token->type == TOK_HERE_DOC_FROM)
		fd = 0;
	if (next_token->type == TOK_ENV)
		expanded_filename = expand_var(ctx, next_token->value);
	else
		expanded_filename = handle_quotes_and_vars(ctx, next_token->value);
	if (!expanded_filename)
		return (-1);
	result = command_add_redirection(cmd, token->type, fd, expanded_filename);
	free(expanded_filename);
	return (result);
}

/**
 * @brief Processes tokens until end of command or pipeline marker
 *
 * @param current Current token pointer reference
 * @param cmd Current command being built
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_command_tokens(t_token **current, t_command *cmd,
		t_ctx *ctx)
{
	while (*current && (*current)->type != TOK_PIPE)
	{
		if ((*current)->type == TOK_WORD)
		{
			if (!process_word_token(cmd, *current, ctx))
				return (false);
		}
		else if ((*current)->type == TOK_ENV)
		{
			if (!process_env_token(cmd, *current, ctx))
				return (false);
		}
		else if (token_is_redirection((*current)->type))
		{
			if ((*current)->next && handle_redirection_token(cmd, *current,
					(*current)->next, ctx) == -1)
				return (false);
			if ((*current)->next)
				*current = (*current)->next;
		}
		if (*current)
			*current = (*current)->next;
	}
	return (true);
}

/**
 * @brief Creates commands for a pipeline of commands
 *
 * @param cmd Current command pointer reference
 * @param current Current token pointer reference
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	create_pipeline(t_command **cmd, t_token **current, t_ctx *ctx)
{
	t_command	*new_cmd;

	if (*current && (*current)->type == TOK_PIPE)
	{
		new_cmd = command_new();
		if (!new_cmd)
			return (false);
		(*cmd)->next = new_cmd;
		*cmd = new_cmd;
		*current = (*current)->next;
		if (!process_command_tokens(current, *cmd, ctx))
			return (false);
		if (*current && (*current)->type == TOK_PIPE)
			return (create_pipeline(cmd, current, ctx));
	}
	return (true);
}

/**
 * @brief Parses tokens into a command structure
 *
 * @param ctx Context containing environment information
 * @param tokens The tokens array to parse
 * @return t_command* Parsed command structure
 */
t_command	*command_parse(t_ctx *ctx, t_token *tokens)
{
	t_command	*cmd;
	t_command	*first_cmd;
	t_token		*current;

	cmd = command_new();
	if (!cmd)
		return (NULL);
	first_cmd = cmd;
	current = tokens;
	if (!process_command_tokens(&current, cmd, ctx))
	{
		free_all_commands(first_cmd);
		return (NULL);
	}
	if (!create_pipeline(&cmd, &current, ctx))
	{
		free_all_commands(first_cmd);
		return (NULL);
	}
	return (first_cmd);
}
</file>

<file path="src/command/command_redirections.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 17:36:47 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 17:37:44 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Sets up input/output redirections for a command
 *
 * @param redirections List of redirections
 * @return int 0 on success, -1 on failure
 */
int	handle_redirections(t_redirection *redirections)
{
	t_redirection	*redir;
	int				fd;

	redir = redirections;
	while (redir)
	{
		if (redir->type == TOK_REDIR_FROM)
		{
			fd = open(redir->filename, O_RDONLY);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDIN_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_REDIR_TO)
		{
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDOUT_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_HERE_DOC_TO)
		{
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDOUT_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_HERE_DOC_FROM)
		{
			// TODO: Implement heredoc with a pipe rather than a temp file
		}
		redir = redir->next;
	}
	return (0);
}
</file>

<file path="src/debug/debug_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 14:36:02 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 13:04:44 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_tokens_list(t_token *tokens)
{
	t_token	*current;
	int		token_count;

	current = tokens;
	token_count = 0;
	ft_printf(YELLOW "\n===== TOKEN LIST =====\n" RESET);
	while (current)
	{
		ft_printf(GREEN "Token %d: " RESET, token_count++);
		ft_printf("Type: " YELLOW);
		switch (current->type)
		{
		case TOK_WORD:
			ft_printf("WORD");
			break ;
		case TOK_REDIR_FROM:
			ft_printf("REDIR_FROM");
			break ;
		case TOK_REDIR_TO:
			ft_printf("REDIR_TO");
			break ;
		case TOK_HERE_DOC_FROM:
			ft_printf("HERE_DOC_FROM");
			break ;
		case TOK_HERE_DOC_TO:
			ft_printf("HERE_DOC_TO");
			break ;
		case TOK_PIPE:
			ft_printf("PIPE");
			break ;
		case TOK_ENV:
			ft_printf("ENV");
			break ;
		case TOK_AND:
			ft_printf("AND");
			break ;
		case TOK_OR:
			ft_printf("OR");
			break ;
		case TOK_NEW_LINE:
			ft_printf("NEW_LINE");
			break ;
		case TOK_EOF:
			ft_printf("EOF");
			break ;
		default:
			ft_printf("UNKNOWN");
			break ;
		}
		ft_printf(RESET);
		if (current->value)
			ft_printf(" | Value: " GREEN "%s" RESET, current->value);
		else
			ft_printf(" | Value: " GREEN "NULL" RESET);
		ft_printf("\n");
		current = current->next;
	}
	ft_printf(YELLOW "=====================\n\n" RESET);
}

void	print_redirection_type(t_token_type type)
{
	if (type == TOK_REDIR_FROM)
		ft_printf("< (REDIR_FROM)");
	else if (type == TOK_REDIR_TO)
		ft_printf("> (REDIR_TO)");
	else if (type == TOK_HERE_DOC_FROM)
		ft_printf("<< (HERE_DOC_FROM)");
	else if (type == TOK_HERE_DOC_TO)
		ft_printf(">> (HERE_DOC_TO)");
	else
		ft_printf("UNKNOWN");
}

void	print_redirections(t_redirection *redir)
{
	t_redirection	*current;
	int				redir_count;

	redir_count = 0;
	current = redir;
	if (!current)
	{
		ft_printf(YELLOW "  No redirections\n" RESET);
		return ;
	}
	ft_printf(YELLOW "  Redirections:\n" RESET);
	while (current)
	{
		ft_printf(GREEN "    Redirection %d: " RESET, redir_count++);
		ft_printf("Type: " YELLOW);
		print_redirection_type(current->type);
		ft_printf(RESET);
		ft_printf(" | Filename: " GREEN "%s" RESET, current->filename);
		ft_printf("\n");
		current = current->next;
	}
}

static char	*get_display_value(char *str)
{
	int		i;
	int		j;
	char	*result;
	int		in_squote;
	int		in_dquote;

	if (!str)
		return (ft_strdup("NULL"));
	result = malloc(ft_strlen(str) + 1);
	if (!result)
		return (ft_strdup("[malloc error]"));
	i = 0;
	j = 0;
	in_squote = 0;
	in_dquote = 0;
	while (str[i])
	{
		if (str[i] == '\'' && !in_dquote)
			in_squote = !in_squote;
		else if (str[i] == '"' && !in_squote)
			in_dquote = !in_dquote;
		else
			result[j++] = str[i];
		i++;
	}
	result[j] = '\0';
	return (result);
}

void	print_command_args(t_command *cmd)
{
	int		i;
	char	*display_value;

	i = 0;
	if (!cmd->args || cmd->arg_count == 0)
	{
		ft_printf(YELLOW "  No arguments\n" RESET);
		return ;
	}
	ft_printf(YELLOW "  Arguments:\n" RESET);
	while (i < cmd->arg_count)
	{
		display_value = get_display_value(cmd->args[i]);
		ft_printf(GREEN "    Arg %d: " RESET "%s\n", i, display_value);
		free(display_value);
		i++;
	}
}

void	print_operator_type(t_token_type op_type)
{
	if (op_type == TOK_PIPE)
		ft_printf(BLUE "  Piped to next command (|)\n" RESET);
	else if (op_type == TOK_OR)
		ft_printf(BLUE "  OR operator to next command (||)\n" RESET);
	else if (op_type == TOK_AND)
		ft_printf(BLUE "  AND operator to next command (&&)\n" RESET);
}

void	print_commands(t_command *cmd)
{
	t_command	*current;
	int			cmd_count;

	cmd_count = 0;
	current = cmd;
	ft_printf(YELLOW "\n===== COMMANDS =====\n" RESET);
	if (!current)
	{
		ft_printf(RED "No commands to display\n" RESET);
		ft_printf(YELLOW "===================\n\n" RESET);
		return ;
	}
	while (current)
	{
		ft_printf(GREEN "Command %d:\n" RESET, cmd_count++);
		print_command_args(current);
		print_redirections(current->redirection);
		if (current->next)
			print_operator_type(current->operator);
		current = current->next;
	}
	ft_printf(YELLOW "===================\n\n" RESET);
}

void	print_token_type(t_token_type type)
{
	if (type == TOK_WORD)
		ft_printf("WORD");
	else if (type == TOK_REDIR_FROM)
		ft_printf("REDIR_FROM");
	else if (type == TOK_REDIR_TO)
		ft_printf("REDIR_TO");
	else if (type == TOK_HERE_DOC_FROM)
		ft_printf("HERE_DOC_FROM");
	else if (type == TOK_HERE_DOC_TO)
		ft_printf("HERE_DOC_TO");
	else if (type == TOK_PIPE)
		ft_printf("PIPE");
	else if (type == TOK_ENV)
		ft_printf("ENV");
	else if (type == TOK_AND)
		ft_printf("AND");
	else if (type == TOK_OR)
		ft_printf("OR");
	else if (type == TOK_NEW_LINE)
		ft_printf("NEW_LINE");
	else if (type == TOK_EOF)
		ft_printf("EOF");
	else
		ft_printf("UNKNOWN");
}

void	print_single_token(t_token *token, int count)
{
	char	*display_value;

	ft_printf(GREEN "Token %d: " RESET, count);
	ft_printf("Type: " YELLOW);
	print_token_type(token->type);
	ft_printf(RESET);
	if (token->value)
	{
		display_value = get_display_value(token->value);
		ft_printf(" | Value: " GREEN "%s" RESET, display_value);
		free(display_value);
	}
	else
		ft_printf(" | Value: " GREEN "NULL" RESET);
	ft_printf("\n");
}

void	print_tokens(t_token *tokens)
{
	t_token	*current;
	int		token_count;

	current = tokens;
	token_count = 0;
	ft_printf(YELLOW "\n===== TOKEN LIST =====\n" RESET);
	if (!current)
	{
		ft_printf(RED "No tokens to display\n" RESET);
		ft_printf(YELLOW "=====================\n\n" RESET);
		return ;
	}
	while (current)
	{
		print_single_token(current, token_count);
		token_count++;
		current = current->next;
	}
	ft_printf(YELLOW "=====================\n\n" RESET);
}

void	cleanup(t_token *tokens)
{
	if (tokens)
		free_all_token(tokens);
	clear_history();
	rl_clear_history();
	rl_free_line_state();
	rl_cleanup_after_signal();
}

void	handle_signal(int sig)
{
	(void)sig;
	ft_printf("\nExiting...\n");
	cleanup(NULL);
	exit(0);
}

// #include <signal.h>

// int	main(int argc, char **argv, char **envp)
// {
// 	char		*input;
// 	t_token		*tokens;
// 	t_command	*commands;
// 	t_ctx		*ctx;
// 	int			status;

// 	(void)argc;
// 	(void)argv;
// 	ctx = init_ctx(argc, argv, envp);
// 	if (!ctx)
// 		return (1);
// 	status = 0;
// 	while (status == 0)
// 	{
// 		input = readline(YELLOW "minishell$ " RESET);
// 		if (!input)
// 			break ;
// 		if (input[0] != '\0')
// 			add_history(input);
// 		if (ft_strncmp(input, "exit", ft_strlen(input)) == 0)
// 		{
// 			free(input);
// 			break ;
// 		}
// 		tokens = tokenize(NULL, input);
// 		if (tokens)
// 		{
// 			print_tokens(tokens);
// 			commands = parse_token(tokens, ctx);
// 			if (commands)
// 			{
// 				print_commands(commands);
// 				free_all_commands(commands);
// 			}
// 			free_all_token(tokens);
// 		}
// 		free(input);
// 	}
// 	free_env_list(ctx->env_list);
// 	free(ctx);
// 	return (0);
// }

// /**
//  * @brief Processes a single line from input file
//  *
//  * @param ctx Shell context
//  * @param line Line to process
//  * @return 0 to continue, 1 to exit
//  */
// static int process_line(t_ctx *ctx, char *line)
// {
// 	t_token		*tokens;
// 	t_command	*commands;
//
// 	if (!line || line[0] == '\0')
// 		return (0);
// 	if (line[0] == '#')
// 		return (0);
// 	if (ft_strncmp(line, "exit", ft_strlen("exit")) == 0
// 		&& (line[4] == ' ' || line[4] == '\0' || line[4] == '\n'))
// 		return (1);
// 	ft_printf(BLUE"[Command]"RESET" %s\n", line);
// 	tokens = tokenize(line);
// 	if (!tokens)
// 	{
// 		ft_printf(RED"Error: Failed to tokenize input\n"RESET);
// 		return (0);
// 	}
// 	print_tokens(tokens);
// 	commands = parse_token(tokens, ctx);
// 	if (!commands)
// 	{
// 		ft_printf(RED"Error: Failed to parse tokens\n"RESET);
// 		free_all_token(tokens);
// 		return (0);
// 	}
// 	print_commands(commands);
// 	free_all_commands(commands);
// 	free_all_token(tokens);
// 	return (0);
// }
//
// /**
//  * @brief Processes commands from a file
//  *
//  * @param ctx Shell context
//  * @param filename Name of file to read commands from
//  * @return Exit status
//  */
// static int process_file(t_ctx *ctx, char *filename)
// {
// 	int		fd;
// 	char	*line;
// 	int		exit_status;
//
// 	fd = open(filename, O_RDONLY);
// 	if (fd < 0)
// 	{
// 		ft_printf(RED"Error: Could not open file %s\n"RESET, filename);
// 		return (1);
// 	}
// 	ft_printf(GREEN"Processing commands from file: %s\n"RESET, filename);
// 	exit_status = 0;
// 	while (1)
// 	{
// 		line = get_next_line(fd);
// 		if (!line)
// 			break ;
// 		if (line[ft_strlen(line) - 1] == '\n')
// 			line[ft_strlen(line) - 1] = '\0';
//
// 		if (process_line(ctx, line))
// 		{
// 			exit_status = ctx->exit_status;
// 			free(line);
// 			break ;
// 		}
// 		free(line);
// 	}
// 	close(fd);
// 	return (exit_status);
// }
//
// int	main(int argc, char **argv, char **envp)
// {
// 	t_ctx	*ctx;
// 	int		exit_status;
//
// 	ctx = init_ctx(envp);
// 	if (!ctx)
// 		return (1);
// 	ctx->interactive = 0;
// 	if (argc < 2)
// 	{
// 		ft_printf(RED"Usage: %s <filename>\n"RESET, argv[0]);
// 		free_ctx(ctx);
// 		return (1);
// 	}
// 	exit_status = process_file(ctx, argv[1]);
// 	free_ctx(ctx);
// 	return (exit_status);
// }
</file>

<file path="src/debug/debug.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:20:06 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 13:45:03 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"

int					g_debug_level = DEBUG_NONE;

/**
 * @brief Initialize debug system with specified verbosity level
 *
 * @param level Debug verbosity level
 */
void	debug_init(int level)
{
	g_debug_level = level;
}

/**
 * @brief Log a debug message if current level is high enough
 *
 * @param level Required debug level to show this message
 * @param module Module name for the log
 * @param msg Log message to display
 */
void	debug_log(int level, const char *module, const char *msg)
{
	if (g_debug_level >= level)
	{
		ft_putstr_fd((char *)CYAN, STDERR_FILENO);
		ft_putstr_fd((char *)"[DEBUG] ", STDERR_FILENO);
		if (module)
		{
			ft_putstr_fd((char *)module, STDERR_FILENO);
			ft_putstr_fd((char *)": ", STDERR_FILENO);
		}
		ft_putstr_fd((char *)msg, STDERR_FILENO);
		ft_putstr_fd((char *)RESET, STDERR_FILENO);
		ft_putstr_fd((char *)"\n", STDERR_FILENO);
	}
}

/**
 * @brief Get string representation of token type
 *
 * @param type Token type to convert
 * @return String representing the token type
 */
static const char	*get_token_type_str(t_token_type type)
{
	if (type == TOK_WORD)
		return ("WORD");
	if (type == TOK_REDIR_FROM)
		return ("REDIR_FROM");
	if (type == TOK_REDIR_TO)
		return ("REDIR_TO");
	if (type == TOK_HERE_DOC_FROM)
		return ("HERE_DOC_FROM");
	if (type == TOK_HERE_DOC_TO)
		return ("HERE_DOC_TO");
	if (type == TOK_PIPE)
		return ("PIPE");
	if (type == TOK_ENV)
		return ("ENV");
	if (type == TOK_AND)
		return ("AND");
	if (type == TOK_OR)
		return ("OR");
	if (type == TOK_NEW_LINE)
		return ("NEW_LINE");
	if (type == TOK_EOF)
		return ("EOF");
	return ("UNKNOWN");
}

/**
 * @brief Print a single token for debugging
 *
 * @param level Required debug level to show this
 * @param token Token to print
 */
void	debug_print_token(int level, t_token *token)
{
	char	buffer[512];

	if (g_debug_level < level || !token)
		return ;
	ft_strlcpy(buffer, "Token: Type=", sizeof(buffer));
	ft_strlcat(buffer, get_token_type_str(token->type), sizeof(buffer));
	ft_strlcat(buffer, ", Value=", sizeof(buffer));
	if (token->value)
		ft_strlcat(buffer, token->value, sizeof(buffer));
	else
		ft_strlcat(buffer, "NULL", sizeof(buffer));
	debug_log(level, "lexer", buffer);
}

/**
 * @brief Print all tokens in a list for debugging
 *
 * @param level Required debug level to show this
 * @param tokens Tokens list to print
 */
void	debug_print_tokens(int level, t_token *tokens)
{
	t_token	*current;
	int		count;

	if (g_debug_level < level)
		return ;
	debug_log(level, "lexer", "Token list:");
	current = tokens;
	count = 0;
	while (current)
	{
		debug_print_token(level, current);
		current = current->next;
		count++;
	}
}

/**
 * @brief Print a command structure for debugging
 *
 * @param level Required debug level to show this
 * @param cmd Command to print
 */
void	debug_print_command(int level, t_command *cmd)
{
	char			buffer[512];
	t_redirection	*redir;
	char			*count_str;
	int				i;

	if (g_debug_level < level || !cmd)
		return ;
	debug_log(level, "parser", "Command:");
	if (cmd->args && cmd->args[0])
	{
		ft_strlcpy(buffer, "Command name: ", sizeof(buffer));
		ft_strlcat(buffer, cmd->args[0], sizeof(buffer));
		debug_log(level, "parser", buffer);
	}
	i = 1;
	while (cmd->args && i <= cmd->arg_count)
	{
		ft_strlcpy(buffer, "Arg[", sizeof(buffer));
		count_str = ft_itoa(i - 1);
		ft_strlcat(buffer, count_str, sizeof(buffer));
		free(count_str);
		ft_strlcat(buffer, "]: ", sizeof(buffer));
		ft_strlcat(buffer, cmd->args[i], sizeof(buffer));
		debug_log(level, "parser", buffer);
		i++;
	}
	redir = cmd->redirection;
	while (redir)
	{
		ft_strlcpy(buffer, "Redirection: type=", sizeof(buffer));
		ft_strlcat(buffer, get_token_type_str(redir->type), sizeof(buffer));
		ft_strlcat(buffer, ", file=", sizeof(buffer));
		ft_strlcat(buffer, redir->filename, sizeof(buffer));
		debug_log(level, "parser", buffer);
		redir = redir->next;
	}
}

/**
 * @brief Print all commands in a pipeline for debugging
 *
 * @param level Required debug level to show this
 * @param cmd First command in the pipeline
 */
void	debug_print_commands(int level, t_command *cmd)
{
	t_command	*current;
	int			count;
	char		buffer[64];
	char		*count_str;

	if (g_debug_level < level)
		return ;
	debug_log(level, "parser", "Command pipeline:");
	current = cmd;
	count = 0;
	while (current)
	{
		count_str = ft_itoa(count);
		ft_strlcpy(buffer, "Command #", sizeof(buffer));
		ft_strlcat(buffer, count_str, sizeof(buffer));
		free(count_str);
		debug_log(level, "parser", buffer);
		debug_print_command(level, current);
		if (current->next)
		{
			ft_strlcpy(buffer, "Operator: ", sizeof(buffer));
			ft_strlcat(buffer, get_token_type_str(current->operator),
				sizeof(buffer));
			debug_log(level, "parser", buffer);
		}
		current = current->next;
		count++;
	}
}
</file>

<file path="src/env/env_find_bin.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_find_bin.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:40:56 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:46:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "error.h"

/**
 * @brief Creates default path directories when PATH env var is not set
 *
 * @return char** Array of default path directories or NULL if error
 */
static char	**create_default_path_dirs(void)
{
	char	**path_dirs;

	path_dirs = malloc(sizeof(char *) * 5);
	if (!path_dirs)
		return (NULL);
	path_dirs[0] = ft_strdup("/bin");
	path_dirs[1] = ft_strdup("/usr/bin");
	path_dirs[2] = ft_strdup("/usr/local/bin");
	path_dirs[3] = ft_strdup("/sbin");
	path_dirs[4] = NULL;
	return (path_dirs);
}

/**
 * @brief Normalizes path directories by removing trailing slashes
 *
 * @param path_dirs Array of path directories to normalize
 */
static void	normalize_path_dirs(char **path_dirs)
{
	int	i;
	int	len;

	i = 0;
	while (path_dirs[i])
	{
		len = (int)ft_strlen(path_dirs[i]);
		if (len > 0 && path_dirs[i][len - 1] == '/')
			path_dirs[i][len - 1] = '\0';
		i++;
	}
}

/**
 * @brief Gets PATH directories from environment
 *
 * @param ctx Context
 * @return char** Array of path directories or NULL if error
 */
static char	**env_get_path_dirs(t_ctx *ctx)
{
	char	*path_var;
	char	**path_dirs;

	path_var = env_find(ctx, (char *)"PATH=");
	if (!path_var)
		return (create_default_path_dirs());
	path_dirs = ft_split(path_var, ':');
	free(path_var);
	if (!path_dirs)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	normalize_path_dirs(path_dirs);
	return (path_dirs);
}

/**
 * @brief Tries to find a binary in PATH
 *
 * @param ctx Context
 * @param bin The binary to search for
 * @return char* A full path to the binary if found and executable, or NULL
 */
char	*env_find_bin(t_ctx *ctx, char *bin)
{
	char	**path_dirs;
	char	**og_path_dirs;
	char	*path;

	if (!bin)
		return (NULL);
	path_dirs = env_get_path_dirs(ctx);
	if (!path_dirs)
		return (NULL);
	og_path_dirs = path_dirs;
	while (*path_dirs)
	{
		path = bin_find_path(*path_dirs, bin);
		if (path)
		{
			free_2d_array((void **)og_path_dirs);
			return (path);
		}
		path_dirs++;
	}
	free_2d_array((void **)og_path_dirs);
	return (NULL);
}
</file>

<file path="src/env/env_find.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_find.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:13:07 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 14:40:05 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Search for a variable in the environment and return a duplicate
 *
 * @param app The app structure
 * @param var The variable to search for
 * @return char* Environment variable content
 *
 * @note The searched variable *must* end with a '='
 */
char	*env_find(t_ctx *ctx, char *var)
{
	size_t	i;
	size_t	len;
	char	*env_var;

	if (!ctx->envp)
		return (NULL);
	i = 0;
	len = ft_strlen(var);
	while (ctx->envp[i])
	{
		if (ft_strncmp(ctx->envp[i], var, len) == 0)
		{
			env_var = ft_strdup(ctx->envp[i] + len);
			return (env_var);
		}
		i++;
	}
	return (NULL);
}
</file>

<file path="src/env/env_quotes.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_quotes.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/18 17:55:13 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 17:08:51 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Checks if a character is a single quote
 *
 * @param c Character to check
 * @return 1 if single quote, 0 otherwise
 */
static int	is_single_quote(char c)
{
	return (c == '\'');
}

/**
 * @brief Checks if a character is a double quote
 *
 * @param c Character to check
 * @return 1 if double quote, 0 otherwise
 */
static int	is_double_quote(char c)
{
	return (c == '"');
}

/**
 * @brief Updates quote state based on current character
 *
 * @param c Current character
 * @param in_squote Pointer to single quote state
 * @param in_dquote Pointer to double quote state
 */
static void	update_quote_state(char c, int *in_squote, int *in_dquote)
{
	if (is_single_quote(c) && !(*in_dquote))
		*in_squote = !(*in_squote);
	else if (is_double_quote(c) && !(*in_squote))
		*in_dquote = !(*in_dquote);
}

/**
 * @brief Handles expanding variables during string processing
 *
 * @param ctx Context containing environment information
 * @param str Input string
 * @param i Position in string (will be updated)
 * @param result Current result string
 * @return Updated result string
 */
static char	*handle_var_expansion(t_ctx *ctx, char *str, int *i, char *result)
{
	char	*var_value;
	char	*temp_result;
	int		in_squote;

	in_squote = 0;
	var_value = expand_variable(ctx, str, i, in_squote);
	if (!var_value)
		return (result);
	temp_result = join_and_free(result, var_value);
	free(var_value);
	return (temp_result);
}

/**
 * @brief Processes a string, handling quotes and variable expansion
 *
 * @param ctx Context containing variable information
 * @param str String to process
 * @param result Current result string
 * @return Updated result string
 */
static char	*process_string(t_ctx *ctx, char *str, char *result)
{
	int		i;
	int		start;
	int		in_squote;
	int		in_dquote;
	char	*temp_result;

	i = 0;
	start = 0;
	in_squote = 0;
	in_dquote = 0;
	while (str[i])
	{
		update_quote_state(str[i], &in_squote, &in_dquote);
		if (str[i] == '$' && !in_squote)
		{
			temp_result = append_part(result, str, start, i);
			if (!temp_result)
				return (result);
			result = temp_result;
			result = handle_var_expansion(ctx, str, &i, result);
			start = i;
			continue ;
		}
		i++;
	}
	temp_result = append_part(result, str, start, i);
	return (temp_result);
}

/**
 * @brief Handles quotes and variables in a string
 *
 * @param ctx Context containing variable information
 * @param str Input string to process
 * @return Newly allocated string with processed content
 */
char	*handle_quotes_and_vars(t_ctx *ctx, char *str)
{
	char	*result;
	char	*processed;

	if (!str)
		return (ft_strdup(""));
	result = ft_strdup("");
	if (!result)
		return (NULL);
	processed = process_string(ctx, str, result);
	return (processed);
}
</file>

<file path="src/env/env.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 12:30:04 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 17:08:31 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Process a part of a string and append it to the result
 *
 * @param result Current result string
 * @param str Input string
 * @param start Start position
 * @param end End position
 * @return Updated result string
 */
char	*append_part(char *result, char *str, int start, int end)
{
	char	*part;
	char	*new_result;

	if (end <= start)
		return (result);
	part = ft_substr(str, start, end - start);
	if (!part)
		return (result);
	new_result = join_and_free(result, part);
	free(part);
	return (new_result);
}

/**
 * @brief Gets the value of an environment variable
 *
 * @param env_list Environment variable list
 * @param key Key to look for
 * @return Value of the variable or NULL if not found
 */
char	*get_env_value(t_env *env_list, char *key)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (ft_strncmp(current->key, key, ft_strlen(key)) == 0
			&& ft_strlen(current->key) == ft_strlen(key))
			return (current->value);
		current = current->next;
	}
	return (NULL);
}

/**
 * @brief Expands a single environment variable
 *
 * @param ctx Shell context
 * @param var_name Name of the variable to expand
 * @return New allocated string with variable value or empty string
 */
char	*expand_var(t_ctx *ctx, char *var_name)
{
	char	*value;

	if (!var_name)
		return (ft_strdup(""));
	if (ft_strncmp(var_name, "?", ft_strlen(var_name)) == 0)
		return (ft_itoa(ctx->exit_status));
	value = get_env_value(ctx->env_list, var_name);
	if (value)
		return (ft_strdup(value));
	return (ft_strdup(""));
}

/**
 * @brief Gets a variable name from a string
 *
 * @param str String containing the variable
 * @param pos Position in the string (will be updated)
 * @return Newly allocated string with variable name or NULL
 */
static char	*get_var_name(char *str, int *pos)
{
	char	*name;
	int		len;
	int		i;

	i = *pos;
	if (str[i] == '?')
	{
		(*pos)++;
		return (ft_strdup("?"));
	}
	len = 0;
	while (ft_isalnum(str[i + len]) || str[i + len] == '_')
		len++;
	if (len == 0)
		return (NULL);
	name = malloc(len + 1);
	if (!name)
		return (NULL);
	ft_strlcpy(name, str + i, len + 1);
	*pos += len;
	return (name);
}

/**
 * @brief Handles variable expansion based on quote context
 *
 * @param ctx Shell context
 * @param str Input string
 * @param i Current position (will be updated)
 * @param in_squote Whether in single quotes
 * @return Expanded variable or dollar sign
 */
char	*expand_variable(t_ctx *ctx, char *str, int *i, int in_squote)
{
	char	*var_name;
	char	*var_value;

	(*i)++;
	if (in_squote)
		return (ft_strdup("$"));
	var_name = get_var_name(str, i);
	var_value = expand_var(ctx, var_name);
	free(var_name);
	return (var_value);
}
</file>

<file path="src/error/ctx_error_exit.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ctx_error_exit.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 17:07:35 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:45:59 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Frees context, displays an error and quits with the corresponding
 * exit code
 *
 * @param ctx context
 * @param err error code
 */
void	ctx_error_exit(t_ctx *ctx, t_error_type err)
{
	if (ctx)
		ctx_clear(ctx);
	errno = ctx_error(err);
	exit(errno);
}
</file>

<file path="src/error/error_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:35:19 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 10:35:22 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"

/**
 * @brief Displays an error and gets an exit code
 *
 * @param err Error type
 * @return int Exit code
 */
int	ctx_error(t_error_type err)
{
	return (ctx_error_level(err, ERROR));
}

/**
 * @brief Gets the error table object
 *
 * @return t_error_info* The error table map
 */
t_error_info	*get_error_table(void)
{
	t_error_info	*error_table;

	error_table = malloc(32 * sizeof(t_error_info));
	error_table[ERR_NONE] = (t_error_info){0, "Success", false};
	error_table[ERR_CMD_NOT_FOUND] = (t_error_info){127, "Command not found",
		false};
	error_table[ERR_NO_PERMISSION] = (t_error_info){EACCES, "Permission denied",
		true};
	error_table[ERR_IO_ERROR] = (t_error_info){EIO, "Input/output error", true};
	error_table[ERR_UNIMPLEMENTED] = (t_error_info){ENOSYS,
		"Not implemented yet", true};
	error_table[ERR_ALLOC] = (t_error_info){ENOMEM,
		"Allocation failed. Your RAM might be full", true};
	error_table[ERR_PIPE] = (t_error_info){EPIPE, "Pipe error", false};
	error_table[ERR_CHILD] = (t_error_info){ECHILD, "Fork error", false};
	error_table[ERR_NO_SUCH_FILE] = (t_error_info){ENOENT,
		"No such file or directory", false};
	return (error_table);
}

/**
 * @brief Displays an error and gets an exit code
 *
 * @param err Error type
 * @param level Error level
 * @return int Exit code
 */
int	ctx_error_level(t_error_type err, t_error_level level)
{
	t_error_info	*error_table;
	t_error_info	*info;
	char			*msg;
	int				code;

	error_table = get_error_table();
	info = &error_table[err];
	msg = (char *)info->message;
	if (info->use_perror)
		msg = strerror(info->code);
	error_print(level, "minishell", msg);
	code = info->code;
	free(error_table);
	return (code);
}

/**
 * @brief Print a system error message using errno
 *
 * @param level Error severity level
 * @param module Name of the module where error occurred
 */
static void	error_print_sys(t_error_level level, const char *module)
{
	error_print(level, module, strerror(errno));
}

/**
 * @brief Exit the program with an error message
 *
 * @param ctx Context to clean up
 * @param err Error type to report
 * @param module Name of the module where error occurred
 */
void	error_exit(t_ctx *ctx, t_error_type err, const char *module)
{
	t_error_info	*info;
	t_error_info	*error_table;
	int				code;

	if (ctx)
		ctx_clear(ctx);
	error_table = get_error_table();
	info = &error_table[err];
	if (info->use_perror)
		error_print_sys(FATAL, module);
	else
		error_print(FATAL, module, info->message);
	code = info->code;
	free(error_table);
	exit(code);
}
</file>

<file path="src/error/error.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:20:00 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:19:26 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"

/**
 * @brief Get color code based on error level
 *
 * @param level Error severity level
 * @return Corresponding color code string
 */
static const char	*get_level_color(t_error_level level)
{
	if (level == INFO)
		return (BLUE);
	if (level == WARNING)
		return (YELLOW);
	if (level == ERROR)
		return (RED);
	if (level == FATAL)
		return (MAGENTA);
	return (RESET);
}

/**
 * @brief Get text representation of error level
 *
 * @param level Error severity level
 * @return Text description of the level
 */
static const char	*get_level_text(t_error_level level)
{
	if (level == INFO)
		return ("INFO");
	if (level == WARNING)
		return ("WARNING");
	if (level == ERROR)
		return ("ERROR");
	if (level == FATAL)
		return ("FATAL");
	return ("UNKNOWN");
}

/**
 * @brief Print an error message with appropriate formatting
 *
 * @param level Error severity level
 * @param module Name of the module where error occurred
 * @param msg Error message to display
 */
void	error_print(t_error_level level, const char *module, const char *msg)
{
	const char	*color;
	const char	*level_text;

	color = get_level_color(level);
	level_text = get_level_text(level);
	ft_putstr_fd((char *)color, STDERR_FILENO);
	ft_putstr_fd((char *)"[", STDERR_FILENO);
	ft_putstr_fd((char *)level_text, STDERR_FILENO);
	ft_putstr_fd((char *)"] ", STDERR_FILENO);
	if (module)
	{
		ft_putstr_fd((char *)module, STDERR_FILENO);
		ft_putstr_fd((char *)": ", STDERR_FILENO);
	}
	ft_putstr_fd((char *)msg, STDERR_FILENO);
	ft_putstr_fd((char *)RESET, STDERR_FILENO);
	ft_putstr_fd((char *)"\n", STDERR_FILENO);
}

/**
 * @brief Get numeric error code from error type
 *
 * @param err Error type
 * @return int Integer error code
 */
int	error_code(t_error_type err)
{
	t_error_info	*info;
	t_error_info	*error_table;
	int				code;

	error_table = get_error_table();
	info = &error_table[err];
	code = info->code;
	free(error_table);
	return (code);
}
</file>

<file path="src/exec/exec_cmdas_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:33:08 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:52:37 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Executes a single command in the pipeline
 *
 * @param ctx Context with environment
 * @param cmd Current command to execute
 * @param input_fd Input file descriptor
 * @param output_fd Output file descriptor
 * @return pid_t Process ID of the child
 */
pid_t	exec_piped_command(t_ctx *ctx, t_command *cmd, int input_fd,
		int output_fd)
{
	pid_t	pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork");
		return (-1);
	}
	if (pid == 0)
		setup_child_process(ctx, cmd, input_fd, output_fd);
	return (pid);
}

/**
 * @brief Creates a pipe for the next command
 *
 * @param pipe_fds Array to store pipe file descriptors
 * @return int 0 on success, -1 on error
 */
int	setup_pipe(int pipe_fds[2])
{
	if (pipe(pipe_fds) == -1)
	{
		perror("pipe");
		return (-1);
	}
	return (0);
}

/**
 * @brief Waits for all child processes and reports status
 *
 * @param pids Array of process IDs
 * @param count Number of processes
 * @return int Exit status of the last command
 */
int	wait_for_pids(pid_t *pids, int count)
{
	int	i;
	int	status;
	int	last_status;

	i = 0;
	last_status = 0;
	while (i < count)
	{
		if (pids[i] > 0)
			waitpid(pids[i], &status, 0);
		if (i == count - 1 && pids[i] > 0)
		{
			if (WIFEXITED(status))
				last_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
				last_status = 128 + WTERMSIG(status);
		}
		i++;
	}
	return (last_status);
}
</file>

<file path="src/exec/exec_cmdas_utils2.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas_utils2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:52:23 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:55:36 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Counts the number of commands in a pipeline
 *
 * @param cmd The first command in the pipeline
 * @return int The number of commands
 */
int	count_commands(t_command *cmd)
{
	int			count;
	t_command	*current;

	count = 0;
	current = cmd;
	while (current)
	{
		count++;
		current = current->next;
	}
	return (count);
}

/**
 * @brief Handles command execution after redirection setup
 *
 * @param ctx Context with environment
 * @param cmd Command to execute
 * @return void
 */
static void	execute_command(t_ctx *ctx, t_command *cmd)
{
	char	*bin_path;

	if (builtins_try(ctx, cmd))
		exit(EXIT_SUCCESS);
	if (!cmd->args || !cmd->args[0])
		exit(EXIT_FAILURE);
	bin_path = bin_find(ctx, cmd->args[0]);
	if (!bin_path)
	{
		ft_printf("Command not found: %s\n", cmd->args[0]);
		exit(EXIT_FAILURE);
	}
	free(cmd->args[0]);
	cmd->args[0] = bin_path;
	if (execve(cmd->args[0], cmd->args, ctx->envp) == -1)
	{
		perror("execve");
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Sets up the child process for command execution
 *
 * @param ctx Context with environment
 * @param cmd Command to execute
 * @param input_fd Input file descriptor
 * @param output_fd Output file descriptor
 */
void	setup_child_process(t_ctx *ctx, t_command *cmd, int input_fd,
		int output_fd)
{
	reset_signals();
	if (input_fd != STDIN_FILENO)
	{
		dup2(input_fd, STDIN_FILENO);
		close(input_fd);
	}
	if (output_fd != STDOUT_FILENO)
	{
		dup2(output_fd, STDOUT_FILENO);
		close(output_fd);
	}
	if (handle_redirections(cmd->redirection) != 0)
		exit(EXIT_FAILURE);
	execute_command(ctx, cmd);
}
</file>

<file path="src/exec/exec_cmdas.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 16:37:25 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:37:35 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "memory.h"
#include "minishell.h"

/**
 * @brief Handles pipe setup for commands
 *
 * @param pipe_fds Pipe file descriptors
 * @param i Index of current command
 * @param cmd_count Total command count
 * @return int 0 on success, -1 on error
 */
static int	handle_pipe_setup(int pipe_fds[2], int i, int cmd_count)
{
	if (i < cmd_count - 1)
	{
		if (setup_pipe(pipe_fds) == -1)
			return (-1);
	}
	else
		pipe_fds[1] = STDOUT_FILENO;
	return (0);
}

/**
 * @brief Handles descriptor management after fork
 *
 * @param prev_pipe Previous pipe's read end
 * @param pipe_fds Current pipe file descriptors
 * @param i Current command index
 * @param cmd_count Total command count
 * @return int Updated previous pipe file descriptor
 */
static int	handle_descriptors(int prev_pipe, int pipe_fds[2], int i,
		int cmd_count)
{
	if (prev_pipe != STDIN_FILENO)
		close(prev_pipe);
	if (pipe_fds[1] != STDOUT_FILENO)
		close(pipe_fds[1]);
	if (i < cmd_count - 1)
		return (pipe_fds[0]);
	return (prev_pipe);
}

/**
 * @brief Execute one command in the pipeline process
 *
 * @param ctx Context information
 * @param data Structure with pipe information
 * @return int Updated previous pipe file descriptor
 */
static int	process_pipeline_cmd(t_ctx *ctx, t_pipe_data *data)
{
	if (handle_pipe_setup(data->pipe_fds, data->i, data->cmd_count) == -1)
		return (-1);
	setup_parent_signals();
	data->pids[data->i] = exec_piped_command(ctx, data->current,
			data->prev_pipe, data->pipe_fds[1]);
	return (handle_descriptors(data->prev_pipe, data->pipe_fds, data->i,
			data->cmd_count));
}

/**
 * @brief Initialize pipe data structure
 *
 * @param data Pipe data structure to initialize
 * @param ctx Context with command info
 * @return t_bool TRUE on success, FALSE on failure
 */
static t_bool	init_pipe_data(t_pipe_data *data, t_ctx *ctx)
{
	data->current = ctx->cmd;
	data->cmd_count = count_commands(data->current);
	data->i = 0;
	data->prev_pipe = STDIN_FILENO;
	data->pids = malloc(sizeof(pid_t) * (size_t)data->cmd_count);
	if (!data->pids)
		return (false);
	return (true);
}

/**
 * @brief Execute the commands in a pipeline
 *
 * @param ctx Context
 * @return Exit status of the last command
 */
t_bool	exec_cmdas(t_ctx *ctx)
{
	t_pipe_data	data;
	int			exit_status;
	int			i;
	char		*a;
	char		error_buf[64];

	debug_log(DEBUG_INFO, "pipeline", "Starting pipeline execution");
	if (!init_pipe_data(&data, ctx))
	{
		error_print(ERROR, "pipeline", "Failed to initialize pipeline data");
		return (error_code(ERR_ALLOC));
	}
	setup_parent_signals();
	i = 0;
	while (i < data.cmd_count)
	{
		debug_log(DEBUG_INFO, "pipeline", "Processing command in pipeline");
		data.prev_pipe = process_pipeline_cmd(ctx, &data);
		if (data.prev_pipe == -1)
		{
			free(data.pids);
			error_print(ERROR, "pipeline", "Pipe processing failed");
			return (error_code(ERR_PIPE));
		}
		data.current = data.current->next;
		data.i++;
		i++;
	}
	debug_log(DEBUG_INFO, "pipeline", "Waiting for child processes");
	exit_status = wait_for_pids(data.pids, data.cmd_count);
	ft_strlcpy(error_buf, "Pipeline exit status: ", sizeof(error_buf));
	a = ft_itoa(exit_status);
	ft_strlcat(error_buf, a, sizeof(error_buf));
	free(a);
	debug_log(DEBUG_INFO, "pipeline", error_buf);
	setup_signals();
	free(data.pids);
	return (exit_status);
}
</file>

<file path="src/free/ctx_exit.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ctx_exit.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 17:15:04 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:30:49 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Clears the context and exits the app gracefully
 *
 * @param ctx context
 */
void	ctx_exit(t_ctx *ctx)
{
	ctx_clear(ctx);
	exit(EXIT_SUCCESS);
}
</file>

<file path="src/free/free_2d_array.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_2d_array.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 16:38:09 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 15:07:04 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees a NULL-terminated pointer of pointers
 *
 * @param ptrs The pointer of pointers to free
 */
void	free_2d_array(void **ptrs)
{
	int	i;

	if (!ptrs)
		return ;
	i = 0;
	while (ptrs[i])
	{
		free(ptrs[i]);
		i++;
	}
	free(ptrs);
}
</file>

<file path="src/free/free_command.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_command.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:49:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 14:04:10 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees memory allocated for a redirection structure
 *
 * This function releases all memory associated with a redirection structure
 * including the filename.
 *
 * @param redirection Redirection structure to free
 */
static void	free_redirection(t_redirection *redirection)
{
	if (!redirection)
		return ;
	if (redirection->filename)
		free(redirection->filename);
	free(redirection);
}

/**
 * @brief Frees memory allocated for all redirections in a linked list
 *
 * This function traverses a linked list of redirections and frees each one.
 *
 * @param redirection First redirection in the linked list
 */
static void	free_all_redirections(t_redirection *redirection)
{
	t_redirection	*current;
	t_redirection	*next;

	current = redirection;
	while (current)
	{
		next = current->next;
		free_redirection(current);
		current = next;
	}
}

/**
 * @brief Frees memory allocated for command arguments
 *
 * This function releases all memory associated with the args array.
 *
 * @param args Array of argument strings
 * @param arg_count Number of arguments in the array
 */
static void	free_command_args(char **args, int arg_count)
{
	int	i;

	if (!args)
		return ;
	i = 0;
	while (i <= arg_count)
	{
		if (args[i])
			free(args[i]);
		i++;
	}
	free(args);
}

/**
 * @brief Frees memory allocated for a command structure
 *
 * This function releases all memory associated with a command structure
 * including arguments and redirections.
 *
 * @param cmd Command structure to free
 */
void	free_command(t_command *cmd)
{
	if (!cmd)
		return ;
	free_command_args(cmd->args, cmd->arg_count);
	free_all_redirections(cmd->redirection);
	free(cmd);
}

/**
 * @brief Frees memory allocated for all commands in a pipeline
 *
 * This function traverses a linked list of commands and frees each one.
 *
 * @param cmd First command in the linked list
 */
void	free_all_commands(t_command *cmd)
{
	t_command	*current;
	t_command	*next;

	current = cmd;
	while (current)
	{
		next = current->next;
		free_command(current);
		current = next;
	}
}
</file>

<file path="src/free/free_ctx.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_ctx.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 18:24:28 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 14:03:34 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Clears the context and frees all allocated resources
 *
 * @param ctx context
 */
void	ctx_clear(t_ctx *ctx)
{
	if (!ctx)
		return ;
	if (ctx->tokens)
		free_all_token(ctx->tokens);
	ctx->tokens = NULL;
	if (ctx->cmd)
		free_command(ctx->cmd);
	ctx->cmd = NULL;
	clear_history();
	rl_free_line_state();
	rl_cleanup_after_signal();
	if (ctx->fd_file_in != -1)
		close(ctx->fd_file_in);
	if (ctx->fd_file_out != -1)
		close(ctx->fd_file_out);
	if (ctx->env_list)
		free_env_list(ctx->env_list);
	free(ctx);
}
</file>

<file path="src/free/free_env.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:42:24 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:35:12 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees environment variable list
 *
 * @param env_list List to free
 */
void	free_env_list(t_env *env_list)
{
	t_env	*current;
	t_env	*next;

	current = env_list;
	while (current)
	{
		next = current->next;
		free(current->key);
		if (current->value)
			free(current->value);
		free(current);
		current = next;
	}
}

/**
 * @brief Parses an environment variable string
 *
 * @param env_str Environment variable string (KEY=VALUE)
 * @param env_list Pointer to the environment list
 * @return 1 if successful, 0 on error
 */
int	parse_env_var(char *env_str, t_env **env_list)
{
	char	*equals_pos;
	char	*key;
	char	*value;
	int		key_len;
	int		result;

	equals_pos = ft_strchr(env_str, '=');
	if (!equals_pos)
		return (add_env_var(env_list, env_str, NULL));
	key_len = (int)(equals_pos - env_str);
	key = (char *)malloc((size_t)(key_len + 1));
	if (!key)
		return (0);
	ft_strlcpy(key, env_str, (size_t)(key_len + 1));
	value = equals_pos + 1;
	result = add_env_var(env_list, key, value);
	free(key);
	return (result);
}
</file>

<file path="src/free/pipes_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 10:24:52 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/13 12:09:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Closes all pipe file descriptors if they are valid
 *
 * @param pipes Array of pipe file descriptors
 */
void	close_all_pipes(int pipes[2][2])
{
	if (pipes[0][0] >= 0)
		close(pipes[0][0]);
	if (pipes[0][1] >= 0)
		close(pipes[0][1]);
	if (pipes[1][0] >= 0)
		close(pipes[1][0]);
	if (pipes[1][1] >= 0)
		close(pipes[1][1]);
}

/**
 * @brief Closes only the previous pipe file descriptors
 *
 * @param pipes Array of pipe file descriptors
 * @param cmd_index Current command index
 */
void	close_previous_pipe(int pipes[2][2], int cmd_index)
{
	if (cmd_index > 0)
	{
		if (pipes[0][0] >= 0)
			close(pipes[0][0]);
		if (pipes[0][1] >= 0)
			close(pipes[0][1]);
	}
}
</file>

<file path="src/init/init_ctx.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_ctx.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 10:56:03 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:46:40 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Initializes the environment in the context
 *
 * @param ctx Context
 * @param envp Environment
 */
static void	init_ctx_envp(t_ctx *ctx, char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		if (!parse_env_var(envp[i], &ctx->env_list))
		{
			ctx_clear(ctx);
			return ;
		}
		i++;
	}
}

/**
 * @brief Initializes the context
 *
 * @param argc Arguments count
 * @param argv Arguments
 * @param envp Environment variables
 * @return t_ctx* Context
 */
t_ctx	*init_ctx(int argc, char **argv, char **envp)
{
	t_ctx	*ctx;

	ctx = malloc(sizeof(t_ctx));
	if (!ctx)
		return (NULL);
	ctx->env_list = NULL;
	init_ctx_envp(ctx, envp);
	ctx->exit_status = 0;
	ctx->interactive = 1;
	ctx->tokens = NULL;
	ctx->cmd = NULL;
	ctx->argc = argc;
	ctx->argv = argv;
	ctx->envp = envp;
	ctx->fd_file_in = -1;
	ctx->fd_file_out = -1;
	return (ctx);
}

/**
 * @brief Creates a new environment variable node
 *
 * @param key Key of the environment variable
 * @param value Value of the environment variable
 * @return New environment variable node or NULL if allocation fails
 */
static t_env	*create_env_node(char *key, char *value)
{
	t_env	*new_node;

	new_node = (t_env *)malloc(sizeof(t_env));
	if (!new_node)
		return (NULL);
	new_node->key = ft_strdup(key);
	if (!new_node->key)
	{
		free(new_node);
		return (NULL);
	}
	if (value)
	{
		new_node->value = ft_strdup(value);
		if (!new_node->value)
		{
			free(new_node->key);
			free(new_node);
			return (NULL);
		}
	}
	else
		new_node->value = NULL;
	new_node->next = NULL;
	return (new_node);
}

/**
 * @brief Adds an environment variable to the list
 *
 * @param env_list Pointer to the list head
 * @param key Key of the environment variable
 * @param value Value of the environment variable
 * @return 1 if successful, 0 on error
 */
int	add_env_var(t_env **env_list, char *key, char *value)
{
	t_env	*new_node;
	t_env	*current;

	new_node = create_env_node(key, value);
	if (!new_node)
		return (0);
	if (!*env_list)
	{
		*env_list = new_node;
		return (1);
	}
	current = *env_list;
	while (current->next)
		current = current->next;
	current->next = new_node;
	return (1);
}
</file>

<file path="src/init/init_parse.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_parse.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:14:26 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:36:12 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Creates and initializes a new token
 *
 * @param type Token type enumeration
 * @param value String value of the token
 * @return New token pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_token	*create_token(t_token_type type, char *value)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->type = type;
	token->next = NULL;
	token->value = value;
	return (token);
}

/**
 * @brief Creates and initializes a new command
 *
 * @return New command pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_command	*create_command(void)
{
	t_command	*cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
		return (NULL);
	cmd->redirection = NULL;
	cmd->next = NULL;
	cmd->args = NULL;
	cmd->arg_count = 0;
	return (cmd);
}

/**
 * @brief Creates and initializes a new command
 *
 * @param type
 * @param filename
 * @return New command pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_redirection	*create_redirection(t_token_type type, char *filename)
{
	t_redirection	*redirection;

	redirection = malloc(sizeof(t_redirection));
	if (!redirection)
		return (NULL);
	redirection->type = type;
	redirection->next = NULL;
	redirection->filename = ft_strdup(filename);
	if (!redirection->filename)
	{
		free(redirection);
		return (NULL);
	}
	return (redirection);
}

void	init_parse_context(t_parse *parse, t_token *token)
{
	parse->token = token;
	parse->current = token;
}
</file>

<file path="src/lexer/lexer_read_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_read_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:43:47 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 10:43:50 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Joins two strings and frees the first one
 *
 * @param s1 First string (will be freed)
 * @param s2 Second string
 * @return Newly allocated joined string or NULL on error
 */
char	*join_and_free(char *s1, char *s2)
{
	char	*result;

	if (!s1)
		return (ft_strdup(s2));
	result = ft_strjoin(s1, s2);
	free(s1);
	return (result);
}

/**
 * @brief Handle dollar sign during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @return Updated result buffer with position at dollar sign
 */
char	*handle_dollar_sign(char *result)
{
	if (!result)
		result = ft_strdup("");
	return (result);
}

/**
 * @brief Handle word part during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @return Updated result buffer or NULL on error
 */
char	*handle_word_part(t_lexer *lexer, char *result)
{
	char	*part;

	part = read_word_lexer(lexer);
	result = join_and_free(result, part);
	free(part);
	return (result);
}

/**
 * @brief Handle quoted part during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @param quote_char Quote character (single or double)
 * @return Updated result buffer or NULL on error
 */
char	*handle_quoted_part(t_lexer *lexer, char *result, char quote_char)
{
	char	*part;

	part = read_quoted_string_lexer(lexer, quote_char);
	if (!part)
	{
		free(result);
		return (NULL);
	}
	result = join_and_free(result, part);
	free(part);
	return (result);
}
</file>

<file path="src/lexer/lexer_read.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_read.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:27:07 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:51:57 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Extract a word from lexer input
 *
 * @param lexer Pointer to lexer structure
 * @return Newly allocated string containing the word or NULL on error
 * @note Caller must free the returned string
 */
char	*read_word_lexer(t_lexer *lexer)
{
	int		start;
	int		length;
	char	*word;

	start = lexer->position;
	while (get_lexer(lexer) != '\0' && get_lexer(lexer) != ' '
		&& get_lexer(lexer) != '\t' && get_lexer(lexer) != '\n'
		&& get_lexer(lexer) != '|' && get_lexer(lexer) != '<'
		&& get_lexer(lexer) != '>' && get_lexer(lexer) != '&'
		&& get_lexer(lexer) != '"' && get_lexer(lexer) != '$'
		&& get_lexer(lexer) != '\'')
		advance_lexer(lexer);
	length = lexer->position - start;
	if (length == 0)
		return (ft_strdup(""));
	word = malloc((unsigned long)length + 1);
	if (!word)
		return (NULL);
	ft_strlcpy(word, lexer->input + start, (size_t)length + 1);
	word[length] = '\0';
	return (word);
}

char	*read_quoted_string_lexer(t_lexer *lexer, char quote_char)
{
	int		start;
	int		end;
	char	*content;

	start = lexer->position + 1;
	advance_lexer(lexer);
	while (get_lexer(lexer) != '\0' && get_lexer(lexer) != quote_char)
		advance_lexer(lexer);
	if (get_lexer(lexer) == '\0')
	{
		ft_printf(RED "error:\nUnclosed quote\n" RESET);
		return (NULL);
	}
	end = lexer->position;
	advance_lexer(lexer);
	content = malloc((unsigned long)(end - start + 1));
	if (!content)
		return (NULL);
	ft_strlcpy(content, lexer->input + start, (size_t)(end - start + 1));
	content[end - start] = '\0';
	return (content);
}

static int	peek_lexer(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	return (current != '\0' && current != ' ' && current != '\t'
		&& current != '\n' && current != '|' && current != '<'
		&& current != '>' && current != '&');
}

/**
 * @brief Reads a complex word that might contain various elements
 *
 * @param lexer Pointer to lexer structure
 * @return Newly allocated string containing the word or NULL on error
 */
char	*read_complex_word(t_lexer *lexer)
{
	char	*result;
	char	quote_char;

	result = NULL;
	while (peek_lexer(lexer))
	{
		if (get_lexer(lexer) == '"' || get_lexer(lexer) == '\'')
		{
			quote_char = get_lexer(lexer);
			result = handle_quoted_part(lexer, result, quote_char);
			if (!result)
				return (NULL);
		}
		else if (get_lexer(lexer) == '$')
		{
			result = handle_dollar_sign(result);
			break ;
		}
		else
			result = handle_word_part(lexer, result);
	}
	if (!result)
		return (ft_strdup(""));
	return (result);
}
</file>

<file path="src/lexer/lexer_token_is.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token_is.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:58:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/12 18:00:00 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Checks if a token is a redirection token
 *
 * @param tok Token type to check
 * @return t_bool true if token is a redirection, false otherwise
 */
t_bool	token_is_redirection(t_token_type type)
{
	return (type == TOK_REDIR_FROM || type == TOK_REDIR_TO
		|| type == TOK_HERE_DOC_FROM || type == TOK_HERE_DOC_TO);
}
</file>

<file path="src/lexer/lexer_token_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 15:53:31 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:39:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token	*handle_basics_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '\0')
		return (create_token(TOK_EOF, NULL));
	if (current == '\n')
	{
		advance_lexer(lexer);
		return (create_token(TOK_NEW_LINE, ft_strdup("\n")));
	}
	return (NULL);
}

t_token	*handle_pipe_and_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '|')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '|')
		{
			advance_lexer(lexer);
			return (create_token(TOK_OR, ft_strdup("||")));
		}
		return (create_token(TOK_PIPE, ft_strdup("|")));
	}
	if (current == '&')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '&')
		{
			advance_lexer(lexer);
			return (create_token(TOK_AND, ft_strdup("&&")));
		}
		ft_printf(RED "Error:\nUnexpected '&'\n" RESET);
		return (create_token(TOK_EOF, NULL));
	}
	return (NULL);
}

t_token	*handle_redir_from_and_to_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '<')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '<')
		{
			advance_lexer(lexer);
			return (create_token(TOK_HERE_DOC_FROM, ft_strdup("<<")));
		}
		return (create_token(TOK_REDIR_FROM, ft_strdup("<")));
	}
	else if (current == '>')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '>')
		{
			advance_lexer(lexer);
			return (create_token(TOK_HERE_DOC_TO, ft_strdup(">>")));
		}
		return (create_token(TOK_REDIR_TO, ft_strdup(">")));
	}
	return (NULL);
}

/**
 * Checks if the current lexer character is a lone '$' symbol.
 *
 * @param lexer Pointer to the lexer structure
 * @return 1 if lone '$', 0 otherwise
 */
static int	is_lone_dollar(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	return (current == ' ' || current == '\t' || current == '\0'
		|| current == '<' || current == '>' || current == '|'
		|| current == '"' || current == '\'' || current == '&'
		|| current == '\n');
}

t_token	*handle_env_token(t_lexer *lexer)
{
	char	*word;
	char	current;

	current = get_lexer(lexer);
	if (current == '$')
	{
		advance_lexer(lexer);
		if (is_lone_dollar(lexer))
			return (create_token(TOK_WORD, ft_strdup("$")));
		word = read_word_lexer(lexer);
		if (!word || word[0] == '\0')
		{
			if (word)
				free(word);
			return (create_token(TOK_WORD, ft_strdup(" $")));
		}
		return (create_token(TOK_ENV, word));
	}
	return (NULL);
}
</file>

<file path="src/lexer/lexer_token.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:31:33 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:40:13 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_token	*handle_word_token(t_lexer *lexer)
{
	char	*word;

	word = read_complex_word(lexer);
	if (!word)
		return (NULL);
	if (word[0] == '\0' && get_lexer(lexer) == '$')
	{
		free(word);
		return (handle_env_token(lexer));
	}
	return (create_token(TOK_WORD, word));
}

/**
 * @brief Extracts the next token from the lexer
 *
 * @param lexer Pointer to lexer structure
 * @return Next token or NULL on error
 * @note Caller must free the returned token
 */
t_token	*next_token_lexer(t_lexer *lexer)
{
	t_token	*token;

	skip_whitespace_lexer(lexer);
	token = handle_basics_token(lexer);
	if (token)
		return (token);
	token = handle_pipe_and_token(lexer);
	if (token)
		return (token);
	token = handle_redir_from_and_to_token(lexer);
	if (token)
		return (token);
	if (get_lexer(lexer) == '$')
	{
		token = handle_env_token(lexer);
		if (token)
			return (token);
	}
	token = handle_word_token(lexer);
	if (token)
		return (token);
	return (NULL);
}

static void	free_token(t_token *token)
{
	if (token)
	{
		free(token->value);
		free(token);
	}
}

/**
 * @brief Frees all tokens in a linked list
 *
 * This function releases the memory allocated for all tokens
 * in a linked list, starting from the given token.
 *
 * @param token First token in the list
 */
void	free_all_token(t_token *token)
{
	t_token	*current;
	t_token	*next;

	current = token;
	while (current)
	{
		next = current->next;
		free_token(current);
		current = next;
	}
}
</file>

<file path="src/lexer/lexer_tokenize.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_tokenize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:28:06 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:29:21 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "memory.h"
#include "minishell.h"

/**
 * @brief Adds a token to the linked list, updating head/current pointers
 */
static void	add_token_to_list(t_token **head, t_token **current, t_token *token)
{
	if (!*head)
	{
		*head = token;
		*current = token;
	}
	else
	{
		(*current)->next = token;
		*current = token;
	}
}

/**
 * @brief Builds the token list from lexer input
 */
static int	build_token_list(t_lexer *lexer, t_token **head)
{
	t_token	*token;
	t_token	*current;

	current = NULL;
	while (1)
	{
		token = next_token_lexer(lexer);
		if (!token)
		{
			free_all_token(*head);
			return (0);
		}
		add_token_to_list(head, &current, token);
		if (token->type == TOK_EOF)
			break ;
	}
	return (1);
}

/**
 * @brief Tokenizes input string into a linked list of tokens
 *
 * @param ctx Context for error handling
 * @param input The input string to tokenize
 * @return Linked list of tokens or NULL on error
 */
t_token	*tokenize(t_ctx *ctx, char *input)
{
	t_lexer	*lexer;
	t_token	*head;

	head = NULL;
	debug_log(DEBUG_INFO, "lexer", "Tokenizing input");
	if (!input)
	{
		error_print(ERROR, "lexer", "NULL input string");
		return (NULL);
	}
	lexer = safe_malloc(ctx, sizeof(t_lexer), "lexer");
	lexer->input = input;
	lexer->position = 0;
	lexer->length = (int)ft_strlen(input);
	if (!build_token_list(lexer, &head))
	{
		error_print(ERROR, "lexer", "Failed to build token list");
		free(lexer);
		return (NULL);
	}
	free(lexer);
	debug_log(DEBUG_INFO, "lexer", "Tokenization complete");
	return (head);
}
</file>

<file path="src/lexer/lexer_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:17:06 by maximart          #+#    #+#             */
/*   Updated: 2025/03/05 19:17:08 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Return current character at lexer position
 *
 * @param lexer Pointer to lexer structure
 * @return Current character or '\0' if at end of input
 */
char	get_lexer(t_lexer *lexer)
{
	if (lexer->position >= lexer->length)
		return ('\0');
	return (lexer->input[lexer->position]);
}

/**
 * @brief Advance lexer position by one character
 *
 * @param lexer Pointer to lexer structure
 */
void	advance_lexer(t_lexer *lexer)
{
	if (lexer->position < lexer->length)
		lexer->position++;
}

/**
 * @brief Skip whitespaces characters in lexer input
 *
 * @param lexer Pointer to lexer structure
 */
void	skip_whitespace_lexer(t_lexer *lexer)
{
	while (get_lexer(lexer) == ' ' || get_lexer(lexer) == '\t')
		advance_lexer(lexer);
}
</file>

<file path="src/memory/memory.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:34:04 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:34:09 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "memory.h"

/**
 * @brief Safely allocates memory with error handling
 *
 * @param ctx Shell context for error handling
 * @param size Size to allocate
 * @param module Module name for error reporting
 * @return Allocated memory or exits on failure
 */
void	*safe_malloc(t_ctx *ctx, size_t size, const char *module)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		error_print(FATAL, module, "Memory allocation failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (ptr);
}

/**
 * @brief Safely duplicates a string with error handling
 *
 * @param ctx Shell context for error handling
 * @param str String to duplicate
 * @param module Module name for error reporting
 * @return Duplicated string or exits on failure
 */
char	*safe_strdup(t_ctx *ctx, const char *str, const char *module)
{
	char	*dup;

	if (!str)
		return (NULL);
	dup = ft_strdup(str);
	if (!dup)
	{
		error_print(FATAL, module, "String duplication failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (dup);
}

/**
 * @brief Safely joins two strings with error handling
 *
 * @param ctx Shell context for error handling
 * @param s1 First string
 * @param s2 Second string
 * @param module Module name for error reporting
 * @return Joined string or exits on failure
 */
char	*safe_strjoin(t_ctx *ctx, const char *s1, const char *s2,
		const char *module)
{
	char	*result;

	result = ft_strjoin(s1, s2);
	if (!result)
	{
		error_print(FATAL, module, "String join failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (result);
}

/**
 * @brief Safely allocates and zeros memory with error handling
 *
 * @param ctx Shell context for error handling
 * @param nmemb Number of elements
 * @param size Size of each element
 * @param module Module name for error reporting
 * @return Allocated memory or exits on failure
 */
void	*safe_calloc(t_ctx *ctx, size_t nmemb, size_t size, const char *module)
{
	void	*ptr;

	ptr = ft_calloc(nmemb, size);
	if (!ptr)
	{
		error_print(FATAL, module, "Memory allocation failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (ptr);
}
</file>

<file path="src/parser/parser_command.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_command.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:37:01 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:47:01 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Adds an argument to a command
 *
 * This function adds a new argument to a command's argument list,
 * allocating memory as needed.
 *
 * @param cmd Command to add the argument to
 * @param value Value of the argument to add
 * @return 1 on success, 0 on failure
 */
int	add_argument(t_command *cmd, char *value)
{
	char	**new_args;
	int		i;

	if (!cmd || !value)
		return (0);
	new_args = malloc(sizeof(char *) * (size_t)(cmd->arg_count + 2));
	if (!new_args)
		return (0);
	i = -1;
	while (++i < cmd->arg_count)
		new_args[i] = cmd->args[i];
	new_args[i] = ft_strdup(value);
	if (!new_args[i])
	{
		free(new_args);
		return (0);
	}
	new_args[i + 1] = NULL;
	if (cmd->args)
		free(cmd->args);
	cmd->args = new_args;
	cmd->arg_count++;
	return (1);
}

/**
 * @brief Adds a redirection to a command
 *
 * This function adds a new redirection to a command's redirection list.
 *
 * @param cmd Command to add the redirection to
 * @param redirection Redirection to add
 */
void	add_redirection(t_command *cmd, t_redirection *redirection)
{
	t_redirection	*current;

	if (!cmd->redirection)
	{
		cmd->redirection = redirection;
		return ;
	}
	current = cmd->redirection;
	while (current->next)
		current = current->next;
	current->next = current;
}

/**
 * @brief Parses a redirection with environment variable expansion
 *
 * @param parse Parser context
 * @param cmd Command structure
 * @param ctx Shell context
 * @return 1 if successful, 0 on error
 */
int	parse_redirection(t_parse *parse, t_command *cmd, t_ctx *ctx)
{
	t_token_type	type;
	t_redirection	*redirection;
	char			*expanded;

	type = parse->current->type;
	advance_parse(parse);
	if (!parse->current || parse->current->type != TOK_WORD)
	{
		ft_printf(RED "Error: Expected filename after redirection\n" RESET);
		return (0);
	}
	if (type == TOK_HERE_DOC_FROM)
		redirection = create_redirection(type, parse->current->value);
	else
	{
		expanded = handle_quotes_and_vars(ctx, parse->current->value);
		redirection = create_redirection(type, expanded);
		free(expanded);
	}
	if (!redirection)
		return (0);
	add_redirection(cmd, redirection);
	advance_parse(parse);
	return (1);
}

/**
 * @brief Parses a command with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_command(t_parse *parse, t_ctx *ctx)
{
	t_command	*cmd;
	char		*expanded;

	cmd = create_command();
	if (!cmd)
		return (NULL);
	while (parse->current && parse->current->type != TOK_PIPE
		&& parse->current->type != TOK_AND && parse->current->type != TOK_OR
		&& parse->current->type != TOK_EOF)
	{
		if (parse->current->type == TOK_WORD)
		{
			expanded = handle_quotes_and_vars(ctx, parse->current->value);
			if (!add_argument(cmd, expanded))
			{
				free(expanded);
				free_command(cmd);
				return (NULL);
			}
			free(expanded);
			advance_parse(parse);
		}
		else if (parse->current->type == TOK_ENV)
		{
			expanded = expand_var(ctx, parse->current->value);
			if (!add_argument(cmd, expanded))
			{
				free(expanded);
				free_command(cmd);
				return (NULL);
			}
			free(expanded);
			advance_parse(parse);
		}
		else if (parse->current->type == TOK_REDIR_FROM
			|| parse->current->type == TOK_REDIR_TO
			|| parse->current->type == TOK_HERE_DOC_FROM
			|| parse->current->type == TOK_HERE_DOC_TO)
		{
			if (!parse_redirection(parse, cmd, ctx))
			{
				free_command(cmd);
				return (NULL);
			}
		}
		else
			advance_parse(parse);
	}
	return (cmd);
}
</file>

<file path="src/parser/parser_pipeline.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_pipeline.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:39:38 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:48:16 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Parses a pipeline with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_pipeline(t_ctx *ctx, t_parse *parse)
{
	t_command	*first_cmd;
	t_command	*current_cmd;

	first_cmd = parse_command(parse, ctx);
	if (!first_cmd)
		return (NULL);
	current_cmd = first_cmd;
	while (parse->current && (parse->current->type == TOK_PIPE
			|| parse->current->type == TOK_OR
			|| parse->current->type == TOK_AND))
	{
		current_cmd->operator = parse->current->type;
		advance_parse(parse);
		current_cmd->next = parse_command(parse, ctx);
		if (!current_cmd->next)
		{
			free_all_commands(first_cmd);
			return (NULL);
		}
		current_cmd = current_cmd->next;
	}
	return (first_cmd);
}

static void	connect_commands(t_command *left_cmd, t_command *right_cmd,
	t_token_type op_type)
{
	t_command	*last_cmd;

	last_cmd = left_cmd;
	while (last_cmd->next)
		last_cmd = last_cmd->next;
	last_cmd->next = right_cmd;
	last_cmd->operator = op_type;
}

/**
 * @brief Parses a command sequence with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_command_sequence(t_ctx *ctx, t_parse *parse)
{
	t_command		*left_cmd;
	t_command		*right_cmd;
	t_token_type	op_type;

	left_cmd = parse_pipeline(ctx, parse);
	if (!left_cmd)
		return (NULL);
	if (parse->current->type != TOK_AND && parse->current->type != TOK_OR)
		return (left_cmd);
	op_type = parse->current->type;
	advance_parse(parse);
	right_cmd = parse_command_sequence(ctx, parse);
	if (!right_cmd)
	{
		free_all_commands(left_cmd);
		return (NULL);
	}
	connect_commands(left_cmd, right_cmd, op_type);
	return (left_cmd);
}
</file>

<file path="src/parser/parser_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:35:40 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:42:31 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	advance_parse(t_parse *parse)
{
	if (parse->current && parse->current->type != TOK_EOF)
		parse->current = parse->current->next;
}

int	check_parse(t_parse *parse, t_token_type type)
{
	return (parse->current && parse->current->type == type);
}

int	check_token_type(t_parse *parse, t_token_type type)
{
	return (parse->current && parse->current->type == type);
}

char	*get_token_value(t_parse *parse)
{
	if (!parse->current)
		return (NULL);
	return (parse->current->value);
}

int	consume_parse(t_parse *parse, t_token_type type)
{
	if (check_parse(parse, type))
	{
		advance_parse(parse);
		return (1);
	}
	return (0);
}
</file>

<file path="src/path/bin_find_path.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bin_find_path.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:59:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:46:35 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Checks if a file exists and is executable
 *
 * @param path Path to the file to check
 * @return int 1 if file exists and is executable, 0 otherwise
 */
static int	is_executable(const char *path)
{
	if (access(path, F_OK) == 0)
	{
		if (access(path, X_OK) == 0)
			return (1);
	}
	return (0);
}

/**
 * @brief Checks if a binary is found in a directory and is executable
 *
 * @param dir The path to search in
 * @param bin The binary to search for
 * @return char* Full path to binary if found and executable, NULL otherwise
 */
char	*bin_find_path(const char *dir, char *bin)
{
	char	*tmp;
	char	*full_path;

	if (!dir || !bin)
		return (NULL);
	tmp = ft_strjoin(dir, "/");
	if (!tmp)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	full_path = ft_strjoin(tmp, bin);
	free(tmp);
	if (!full_path)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	if (is_executable(full_path))
		return (full_path);
	free(full_path);
	return (NULL);
}
</file>

<file path="src/path/bin_find.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bin_find.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:56:48 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:15:25 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Checks if a string is a path and not just a command
 *
 * @param str The string to check
 * @return t_bool true if the string is a path, false if just a command
 */
static t_bool	is_path(const char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (false);
	if (str[0] == '~' && (str[1] == '/' || str[1] == '\0'))
		return (true);
	if (str[0] == '/')
		return (true);
	while (str[i])
	{
		if (str[i] == '/' || (str[i] == '.' && (str[i + 1] == '/' || str[i
						+ 1] == '\0' || (str[i + 1] == '.' && (str[i + 2] == '/'
							|| str[i + 2] == '\0')))))
			return (true);
		i++;
	}
	return (false);
}

/**
 * @brief Tries to execute file directly if it's a path
 *
 * @param bin Binary path to check
 * @return char* strdup of bin if executable, NULL otherwise
 */
static char	*try_direct_path(char *bin, t_path_error *error_state)
{
	if (access(bin, F_OK) != 0)
	{
		*error_state = PATH_ERR_NOT_FOUND;
		return (NULL);
	}
	if (access(bin, X_OK) != 0)
	{
		*error_state = PATH_ERR_NO_PERMISSION;
		return (NULL);
	}
	return (ft_strdup(bin));
}

/**
 * @brief Resolves a relative path to an absolute path
 *
 * @param bin Path to resolve
 * @return char* Absolute path or NULL on error
 */
static char	*resolve_relative_path(char *bin)
{
	char	*cwd;
	char	*absolute_path;
	char	*tmp;

	if (bin[0] == '/')
		return (ft_strdup(bin));
	cwd = getcwd(NULL, 0);
	if (!cwd)
		return (NULL);
	tmp = ft_strjoin(cwd, "/");
	free(cwd);
	if (!tmp)
		return (NULL);
	absolute_path = ft_strjoin(tmp, bin);
	free(tmp);
	return (absolute_path);
}

/**
 * @brief Finds a binary in the PATH or current directory
 *
 * @param ctx Context
 * @param bin The binary to search for
 * @return char* Path to binary if found, NULL otherwise
 */
char	*bin_find(t_ctx *ctx, char *bin)
{
	char			*path;
	t_path_error	error_state;

	error_state = PATH_ERR_NONE;
	if (!bin)
		return (NULL);
	if (is_path(bin))
	{
		path = try_direct_path(bin, &error_state);
		if (path)
			return (path);
		if (bin[0] != '/' && error_state == PATH_ERR_NONE)
		{
			path = resolve_relative_path(bin);
			if (path && access(path, X_OK) == 0)
				return (path);
			if (path && access(path, F_OK) == 0)
				error_state = PATH_ERR_NO_PERMISSION;
			else
				error_state = PATH_ERR_NOT_FOUND;
			free(path);
		}
		path = bin_find_path(".", bin);
		if (path)
			return (path);
		if (error_state == PATH_ERR_NOT_FOUND)
			error_print(ERROR, bin, "No such file or directory");
		else if (error_state == PATH_ERR_NO_PERMISSION)
			error_print(ERROR, bin, "Permission denied");
		return (NULL);
	}
	else
	{
		path = env_find_bin(ctx, bin);
		if (!path)
			error_print(ERROR, bin, "Command not found");
	}
	return (path);
}
</file>

<file path="src/redir/heredoc.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:30:10 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:56:25 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Replaces a substring in a string with another substring
 *
 * @param str Original string
 * @param start Start index of substring to replace
 * @param end End index of substring to replace
 * @param replacement Replacement string
 * @return Newly allocated string with replacement
 */
static char	*replace_substring(char *str, int start, int end, char *replacement)
{
	char	*prefix;
	char	*suffix;
	char	*temp1;
	char	*temp2;

	prefix = ft_substr(str, 0, start);
	if (!prefix)
		return (NULL);
	suffix = ft_strdup(str + end);
	if (!suffix)
	{
		free(prefix);
		return (NULL);
	}
	temp1 = ft_strjoin(prefix, replacement);
	free(prefix);
	if (!temp1)
	{
		free(suffix);
		return (NULL);
	}
	temp2 = ft_strjoin(temp1, suffix);
	free(temp1);
	free(suffix);
	free(str);
	return (temp2);
}

/**
 * @brief Expands environment variables in a line
 *
 * @param ctx Context containing environment info
 * @param line Line to expand variables in
 * @return Newly allocated string with expanded variables
 */
static char	*expand_variables(t_ctx *ctx, char *line)
{
	char	*result;
	char	*var_start;
	char	*var_name;
	char	*var_value;
	int		i;
	int		j;

	if (!line)
		return (NULL);
	result = ft_strdup(line);
	if (!result)
		return (NULL);
	var_start = ft_strchr(result, '$');
	while (var_start)
	{
		i = var_start - result;
		j = i + 1;
		while (result[j] && (ft_isalnum(result[j]) || result[j] == '_'))
			j++;
		var_name = ft_substr(result, i + 1, j - i - 1);
		if (!var_name)
		{
			free(result);
			return (NULL);
		}
		var_value = env_find(ctx, var_name);
		free(var_name);
		if (!var_value)
			var_value = ft_strdup("");
		if (!var_value)
		{
			free(result);
			return (NULL);
		}
		result = replace_substring(result, i, j, var_value);
		free(var_value);
		if (!result)
			return (NULL);
		var_start = ft_strchr(result, '$');
	}
	return (result);
}

/**
 * @brief Processes a line read for heredoc
 *
 * @param line Line read from input
 * @param ctx Context containing environment information
 * @param pipe_fd File descriptor to write to
 * @return 0 on success, -1 on error
 */
static int	process_heredoc_line(char *line, t_ctx *ctx, int pipe_fd)
{
	char	*expanded_line;

	if (!line)
		return (-1);
	expanded_line = expand_variables(ctx, line);
	free(line);
	if (!expanded_line)
		return (-1);
	write(pipe_fd, expanded_line, ft_strlen(expanded_line));
	write(pipe_fd, "\n", 1);
	free(expanded_line);
	return (0);
}

/**
 * @brief Reads content for heredoc until delimiter is found
 *
 * @param pipe_fd File descriptor to write heredoc content to
 * @param delimiter String marking end of heredoc
 * @param ctx Context containing environment information
 * @return 0 on success, -1 on error, 1 on EOF
 */
static int	read_heredoc_content(int pipe_fd, char *delimiter, t_ctx *ctx)
{
	char	*line;
	int		delimiter_len;

	delimiter_len = ft_strlen(delimiter);
	while (1)
	{
		line = readline("> ");
		if (!line)
		{
			error_print(WARNING, "heredoc",
				"here-document delimited by end-of-file");
			return (1);
		}
		if (ft_strncmp(line, delimiter, delimiter_len + 1) == 0)
		{
			free(line);
			break ;
		}
		if (process_heredoc_line(line, ctx, pipe_fd) == -1)
			return (-1);
	}
	return (0);
}

/**
 * @brief Creates a here-document for input redirection
 *
 * @param ctx Context containing environment information
 * @param delimiter String marking end of heredoc
 * @return File descriptor to read from, or -1 on error
 */
static int	create_heredoc(t_ctx *ctx, char *delimiter)
{
	int	pipe_fds[2];
	int	result;

	if (pipe(pipe_fds) == -1)
	{
		perror("pipe");
		return (-1);
	}
	result = read_heredoc_content(pipe_fds[1], delimiter, ctx);
	close(pipe_fds[1]);
	if (result == -1)
	{
		close(pipe_fds[0]);
		return (-1);
	}
	return (pipe_fds[0]);
}

/**
 * @brief Handles here_doc redirections for a command
 *
 * @param ctx Context containing environment information
 * @param cmd Command containing redirections
 * @return 0 on success, non-zero on error
 */
int	setup_heredocs(t_ctx *ctx, t_command *cmd)
{
	t_redirection	*redir;
	int				heredoc_fd;
	int				dup_result;

	redir = cmd->redirection;
	while (redir)
	{
		if (redir->type == TOK_HERE_DOC_FROM)
		{
			heredoc_fd = create_heredoc(ctx, redir->filename);
			if (heredoc_fd == -1)
				return (-1);
			dup_result = dup2(heredoc_fd, STDIN_FILENO);
			close(heredoc_fd);
			if (dup_result == -1)
			{
				perror("dup2");
				return (-1);
			}
		}
		redir = redir->next;
	}
	return (0);
}
</file>

<file path="src/redir/redirections.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:45:10 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:23:08 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Opens a file based on redirection type
 *
 * @param type Redirection type (input, output, append)
 * @param filename Name of the file to open
 * @return File descriptor or -1 on error
 */
static int	open_redirect_file(t_token_type type, char *filename)
{
	int	fd;

	fd = -1;
	if (type == TOK_REDIR_FROM)
		fd = open(filename, O_RDONLY);
	else if (type == TOK_REDIR_TO)
		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (type == TOK_HERE_DOC_TO)
		fd = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd == -1)
		perror(filename);
	return (fd);
}

/**
 * @brief Redirects standard file descriptors
 *
 * @param fd File descriptor to redirect to/from
 * @param type Type of redirection
 * @return 0 on success, -1 on error
 */
static int	redirect_std_fd(int fd, t_token_type type)
{
	int	target_fd;
	int	dup_result;

	if (fd < 0)
		return (-1);
	if (type == TOK_REDIR_FROM)
		target_fd = STDIN_FILENO;
	else
		target_fd = STDOUT_FILENO;
	dup_result = dup2(fd, target_fd);
	close(fd);
	if (dup_result == -1)
	{
		perror("dup2");
		return (-1);
	}
	return (0);
}

/**
 * @brief Processes a single redirection
 *
 * @param redir Redirection to process
 * @return 0 on success, -1 on error
 */
static int	process_redirection(t_redirection *redir)
{
	int	fd;
	int	redirect_result;

	if (redir->type == TOK_HERE_DOC_FROM)
		return (0);
	fd = open_redirect_file(redir->type, redir->filename);
	if (fd == -1)
		return (-1);
	redirect_result = redirect_std_fd(fd, redir->type);
	return (redirect_result);
}

/**
 * @brief Sets up all redirections for a command
 *
 * @param ctx Context for error handling
 * @param redirections List of redirections
 * @return 0 on success, -1 on error
 */
int	setup_redirections(t_redirection *redirections)
{
	t_redirection	*redir;
	int				result;
	char			error_msg[256];

	redir = redirections;
	if (!redir)
	{
		debug_log(DEBUG_INFO, "redir", "No redirections to process");
		return (0);
	}
	debug_log(DEBUG_INFO, "redir", "Setting up redirections");
	while (redir)
	{
		debug_log(DEBUG_VERBOSE, "redir", "Processing redirection");
		result = process_redirection(redir);
		if (result != 0)
		{
			ft_strlcpy(error_msg, "Failed to set up redirection for: ", 256);
			ft_strlcat(error_msg, redir->filename, 256);
			error_print(ERROR, "redir", error_msg);
			return (result);
		}
		redir = redir->next;
	}
	debug_log(DEBUG_INFO, "redir", "All redirections processed successfully");
	return (0);
}
</file>

<file path="src/signals/signals.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 17:58:55 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 14:42:43 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Global variable to track if we're in a child process
 * This will help us determine how to handle signals.
 */
static volatile sig_atomic_t	g_in_child = 0;

/**
 * @brief Signal handler for interactive mode (shell prompt)
 * Handles SIGINT (CTRL+C) by printing a newline and redisplaying the prompt
 *
 * @param sig Signal number
 */
static void	sig_interactive_handler(int sig)
{
	if (sig == SIGINT)
	{
		write(STDOUT_FILENO, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

/**
 * @brief Sets the child process mode flag
 * Used to determine how to handle signals
 *
 * @param in_child 1 if in child process, 0 otherwise
 */
void	set_child_mode(int in_child)
{
	g_in_child = in_child;
}

/**
 * @brief Sets up signal handlers for interactive mode
 * SIGINT (CTRL+C) is handled by printing a newline and new prompt
 * SIGQUIT (CTRL+\) is ignored
 */
void	setup_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = sig_interactive_handler;
	sa_quit.sa_handler = SIG_IGN;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}

/**
 * @brief Resets signal handlers for child processes
 * SIGINT and SIGQUIT are set to their default behavior
 * This ensures that child processes receive signals normally
 */
void	reset_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = SIG_DFL;
	sa_quit.sa_handler = SIG_DFL;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}

/**
 * @brief Special signal handler setup for the parent process when executing
 * commands
 * This temporarily disables the interactive handler so signals propagate to
 * children
 */
void	setup_parent_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = SIG_IGN;
	sa_quit.sa_handler = SIG_IGN;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}
</file>

<file path="src/test/main.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 17:19:32 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 12:46:40 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Gets a user input with appropriate prompt based on previous status
 *
 * @param prev_status The exit status of the previous command
 * @return char* The input string obtained from readline
 */
static char	*prompted_input(int prev_status) {
  char *rdl_str1;
  char *rdl_str2;
  char *rdl_str3;
  char *input;

  if (prev_status > 0) {
    rdl_str1 = ft_itoa(prev_status);
    rdl_str2 = ft_strjoin("\001\033[33m\002", rdl_str1);
    rdl_str3 = ft_strjoin(rdl_str2, " $ \001\033[0m\002");
    if (!rdl_str3)
      prev_status = -1;
    input = readline(rdl_str3);
    free(rdl_str1);
    free(rdl_str2);
    free(rdl_str3);
  } else
    input = readline("\001\033[32m\002$ \001\033[0m\002");
  return (input);
}

/**
 * @brief Completes the main loop process by executing commands
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 */
static void		main_loop_end(t_ctx *ctx, int prev_status);

/**
 * @brief Main loop that handles input and command processing
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 * @return void* Always returns NULL
 */
static void	*main_loop(t_ctx *ctx, int prev_status) {
  char *input;

  input = prompted_input(prev_status);
  if (!input)
    ctx_exit(ctx);
  if (input[0] != '\0')
    add_history(input);
  ctx->tokens = tokenize(input);
  free(input);
  if (!ctx->tokens)
    return (main_loop(ctx, 0));
  ctx->cmd = command_parse(ctx->tokens);
  if (!ctx->cmd) {
    free_all_token(ctx->tokens);
    ctx->tokens = NULL;
    return (main_loop(ctx, 0));
  }
  main_loop_end(ctx, prev_status);
  return (NULL);
}

/**
 * @brief Processes input and executes commands
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 */
static void	main_loop_end(t_ctx *ctx, int prev_status) {
  t_bool should_exit;
  int status;

  should_exit = false;
  if (ctx->cmd->args && ctx->cmd->args[0] &&
      ft_strncmp(ctx->cmd->args[0], "exit", __INT_MAX__) == 0) {
    ft_putstr("exit\n");
    status = 0;
    should_exit = true;
  }
  if (!should_exit)
    status = command_execute(ctx);
  if (ctx->cmd)
    free_all_commands(ctx->cmd);
  ctx->cmd = NULL;
  if (ctx->tokens)
    free_all_token(ctx->tokens);
  ctx->tokens = NULL;
  if (status == -1)
    status = prev_status;
  if (!should_exit)
    (void)main_loop(ctx, status);
  else
    ctx_clear(ctx);
}

/**
 * @brief Check if we're running in test mode (non-interactive)
 *
 * @return t_bool true if stdin is not a terminal (piped input)
 */
static t_bool	is_test_mode(void) { return (!isatty(STDIN_FILENO)); }

/**
 * @brief Main entrypoint
 *
 * @param argc Arguments count
 * @param argv Arguments
 * @param envp Environment variables
 * @return int Exit code
 */
int	main(int argc, char **argv, char **envp) {
  t_ctx *ctx;

  ctx = init_ctx(argc, argv, envp);
  setup_signals();
  if (is_test_mode())
    rl_outstream = fopen("/dev/null", "w");
  main_loop(ctx, 0);
  if (is_test_mode() && rl_outstream != NULL && rl_outstream != stdout) {
    fclose(rl_outstream);
  }
  ctx_clear(ctx);
  return (EXIT_SUCCESS);
}
</file>

<file path="src/validation/validation.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:39:38 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:49:51 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "validation.h"

/**
 * @brief Validates that the input string is not too long
 *
 * @param input The input string to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_input_length(char *input, t_ctx *ctx)
{
	size_t	len;

	(void)ctx;
	if (!input)
		return (false);
	len = ft_strlen(input);
	if (len > MAX_INPUT_LEN)
	{
		error_print(ERROR, "input", "Input exceeds maximum length");
		return (false);
	}
	return (true);
}

static t_bool	is_valid_env_name(const char *name)
{
	if (!name || !name[0])
	{
		error_print(ERROR, "env", "Empty variable name");
		return (false);
	}
	if (!ft_isalpha(name[0]) && name[0] != '_')
	{
		error_print(ERROR, "env", "Variable name must start with letter or _");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates that an environment variable name is valid
 *
 * @param name The variable name to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_env_var_name(char *name, t_ctx *ctx)
{
	int	i;

	(void)ctx;
	if (!is_valid_env_name(name))
		return (false);
	i = 1;
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
		{
			error_print(ERROR, "env", "Invalid character in variable name");
			return (false);
		}
		i++;
	}
	if (ft_strlen(name) > MAX_VAR_NAME_LEN)
	{
		error_print(ERROR, "env", "Variable name too long");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates a filename for redirections
 *
 * @param filename The filename to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_filename(char *filename, t_ctx *ctx)
{
	(void)ctx;
	if (!filename || !filename[0])
	{
		error_print(ERROR, "redir", "Empty filename");
		return (false);
	}
	if (ft_strlen(filename) > 255)
	{
		error_print(ERROR, "redir", "Filename too long");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates a full command structure
 *
 * @param cmd The command to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_command(t_command *cmd, t_ctx *ctx)
{
	t_redirection	*redir;

	if (!cmd)
		return (false);
	redir = cmd->redirection;
	while (redir)
	{
		if (!validate_filename(redir->filename, ctx))
			return (false);
		redir = redir->next;
	}
	return (true);
}
</file>

<file path="src/main_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:47:37 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:50:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"
#include "validation.h"

/**
 * @brief Creates a prompt string based on previous command status
 *
 * @param prev_status Exit status of previous command
 * @return Formatted prompt string
 */
char	*create_prompt(int prev_status)
{
	char	*rdl_str1;
	char	*rdl_str2;
	char	*rdl_str3;
	char	*prompt;

	prompt = NULL;
	if (prev_status > 0)
	{
		rdl_str1 = ft_itoa(prev_status);
		if (!rdl_str1)
			return (NULL);
		rdl_str2 = ft_strjoin("\001" RED "\002", rdl_str1);
		free(rdl_str1);
		if (!rdl_str2)
			return (NULL);
		rdl_str3 = ft_strjoin(rdl_str2, " $ \001" RESET "\002");
		free(rdl_str2);
		prompt = rdl_str3;
	}
	else
		prompt = ft_strdup("\001" GREEN "\002$ \001" RESET "\002");
	return (prompt);
}

/**
 * @brief Gets user input with appropriate prompt
 *
 * @param ctx Shell context
 * @param prev_status Exit status of previous command
 * @return User input string or NULL on error/EOF
 */
char	*get_user_input(t_ctx *ctx, int prev_status)
{
	char	*prompt;
	char	*input;

	prompt = create_prompt(prev_status);
	if (!prompt)
		error_exit(ctx, ERR_ALLOC, "prompt");
	input = readline(prompt);
	free(prompt);
	if (!input)
	{
		ft_putstr("exit\n");
		return (NULL);
	}
	if (input[0] != '\0')
		add_history(input);
	if (!validate_input_length(input, ctx))
	{
		free(input);
		return (NULL);
	}
	return (input);
}
</file>

<file path="src/main.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 18:10:00 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 17:02:47 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"
#include "validation.h"

/**
 * @brief Processes a command after parsing
 *
 * @param ctx Shell context
 * @param prev_status Previous command exit status
 * @return Exit status of the command
 */
static int	process_command(t_ctx *ctx, int prev_status)
{
	int		status;
	t_bool	should_exit;

	should_exit = false;
	status = prev_status;
	if (ctx->cmd && ctx->cmd->args && ctx->cmd->args[0]
		&& ft_strncmp(ctx->cmd->args[0], "exit", __INT_MAX__) == 0)
	{
		ft_putstr("exit\n");
		should_exit = true;
	}
	if (!should_exit)
		status = command_execute(ctx);
	if (ctx->cmd)
		free_all_commands(ctx->cmd);
	ctx->cmd = NULL;
	if (ctx->tokens)
		free_all_token(ctx->tokens);
	ctx->tokens = NULL;
	if (status == -1)
		status = prev_status;
	if (should_exit)
		ctx->exit_status = 1;
	return (status);
}

/**
 * @brief Tokenizes and parses user input
 *
 * @param ctx Shell context
 * @param input User input string
 * @return true if successful, false on error
 */
static t_bool	parse_user_input(t_ctx *ctx, char *input)
{
	ctx->tokens = tokenize(ctx, input);
	if (g_debug_level > INFO)
		print_tokens(ctx->tokens);
	free(input);
	if (!ctx->tokens)
		return (false);
	debug_print_tokens(DEBUG_VERBOSE, ctx->tokens);
	ctx->cmd = command_parse(ctx, ctx->tokens);
	if (!ctx->cmd)
	{
		free_all_token(ctx->tokens);
		ctx->tokens = NULL;
		return (false);
	}
	debug_print_commands(DEBUG_VERBOSE, ctx->cmd);
	if (!validate_command(ctx->cmd, ctx))
	{
		free_all_token(ctx->tokens);
		ctx->tokens = NULL;
		free_all_commands(ctx->cmd);
		ctx->cmd = NULL;
		return (false);
	}
	return (true);
}

/**
 * @brief Main command loop for the shell
 *
 * @param ctx Shell context
 * @param prev_status Previous command exit status
 */
static void	command_loop(t_ctx *ctx, int prev_status)
{
	char	*input;
	int		status;
	int		running;

	status = prev_status;
	running = 1;
	while (running)
	{
		input = get_user_input(ctx, status);
		if (!input)
			ctx_exit(ctx);
		debug_log(DEBUG_INFO, "main", "Processing user input");
		if (parse_user_input(ctx, input))
			status = process_command(ctx, status);
		if (ctx->exit_status)
			running = 0;
	}
}

/**
 * @brief Checks command line args for debug flags
 *
 * @param argc Argument count
 * @param argv Argument values
 */
static void	check_debug_args(int argc, char **argv)
{
	int	i;

	i = 1;
	while (i < argc)
	{
		if (ft_strncmp(argv[i], "--debug", ft_strlen("--debug")) == 0)
			debug_init(DEBUG_INFO);
		else if (ft_strncmp(argv[i], "--verbose", ft_strlen("--verbose")) == 0)
			debug_init(DEBUG_VERBOSE);
		i++;
	}
}

/**
 * @brief Main entrypoint for the minishell program
 *
 * @param argc Argument count
 * @param argv Argument values
 * @param envp Environment variables array
 * @return int Exit status
 */
int	main(int argc, char **argv, char **envp)
{
	t_ctx	*ctx;

	check_debug_args(argc, argv);
	debug_log(DEBUG_INFO, "main", "Initializing minishell");
	ctx = init_ctx(argc, argv, envp);
	if (!ctx)
		error_exit(NULL, ERR_ALLOC, "context initialization");
	setup_signals();
	debug_log(DEBUG_INFO, "main", "Starting command loop");
	command_loop(ctx, 0);
	ctx_clear(ctx);
	return (EXIT_SUCCESS);
}
</file>

<file path=".editorconfig">
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[{*.{c,h},Makefile}]
indent_style = tab
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
</file>

<file path=".gitignore">
*.o
*.d
.idea/
minishell
minishell_test
testb
repomix-output.txt
file_*.txt
output.txt\\nHeredoc
actual_output.txt
.vscode
</file>

<file path=".gitmodules">
[submodule "libft"]
	path = libft
	url = https://github.com/Manomania/libft
</file>

<file path="files.mk">
SRC_F				= 	builtins/builtins_try \
						command/command_execute \
						command/command_execute_utils \
						command/command_parse \
						command/command_add \
						command/command_new \
						command/command_redirections \
						command/command_bin \
						debug/debug \
						debug/debug_utils \
						env/env \
						env/env_find \
						env/env_find_bin \
						env/env_quotes \
						error/error \
						error/ctx_error_exit \
						error/error_utils \
						exec/exec_cmdas \
						exec/exec_cmdas_utils \
						exec/exec_cmdas_utils2 \
						free/free_env \
						free/free_2d_array \
						free/free_ctx \
						free/ctx_exit \
						free/pipes_utils \
						free/free_command \
						init/init_ctx \
						init/init_parse \
						lexer/lexer_read \
						lexer/lexer_read_utils \
						lexer/lexer_token \
						lexer/lexer_tokenize \
						lexer/lexer_token_utils \
						lexer/lexer_utils \
						lexer/lexer_token_is \
						memory/memory \
						parser/parser_command \
						parser/parser_pipeline \
						parser/parser_utils \
						path/bin_find \
						path/bin_find_path \
						redir/heredoc \
						redir/redirections \
						signals/signals \
						validation/validation \
						main_utils \
						main
TSRC_F			=		$(subst main,test/main,$(SRC_F))
</file>

<file path="Makefile">
########################################################################################################################
#                                                      VARIABLES                                                       #
########################################################################################################################

AUTHOR				:=	maximart && elagouch
NAME				:=	minishell
HEADER				=	$(INC_DIR)minishell.h
CC 					?= 	cc
# Standard compilation checks
CFLAGS 				:= 	-Wall -Wextra -Werror
# Debug
CFLAGS				+=	-g3
# Compability checks
CFLAGS				+=	-Wpedantic
# Dependency management
CFLAGS				+=	-MD -MP
# Warns when a variable declaration shadows another variable
CFLAGS				+=	-Wshadow
# More thorough than -Wunused-result
CFLAGS				+=	-Wunused-result
# Disables pointer arithmetics
# (no `*ptr++`)
CFLAGS				+=	-Wpointer-arith
# Catches more printf/scanf format mismatches
CFLAGS				+=	-Wformat=2
# Warns about == for floats which is sus
CFLAGS				+=	-Wfloat-equal
# Makes strings const char*
CFLAGS				+=	-Wwrite-strings
# Keeps the frame pointer in registers
# Minor performance cost
CFLAGS				+=	-fno-omit-frame-pointer
AR					:=	ar rcs
RM					:=	rm -f

include files.mk

SRC					=	$(addprefix $(SRC_DIR), $(addsuffix .c, $(SRC_F)))
TSRC 				= 	$(addprefix $(SRC_DIR), $(addsuffix .o, $(TSRC_F)))
OBJ 				= 	$(addprefix $(OBJ_DIR), $(addsuffix .o, $(SRC_F)))
TOBJ 				= 	$(addprefix $(OBJ_DIR), $(addsuffix .o, $(TSRC_F)))
DEP 				= 	$(addprefix $(OBJ_DIR), $(addsuffix .d, $(SRC_F)))

########################################################################################################################
#                                                      DIRECTORY                                                       #
########################################################################################################################

SRC_DIR				:=	src/
OBJ_DIR				:=	obj/
INC_DIR				:=	include/

########################################################################################################################
#                                                         LIB                                                          #
########################################################################################################################

LIBFT_DIR			:=	libft/
LIBFT				:=	$(LIBFT_DIR)libft.a

########################################################################################################################
#                                                       TARGETS                                                        #
########################################################################################################################

.print_header:
							$(call DISPLAY_TITLE)
							$(call SEPARATOR)
							$(call BUILD)
							$(call SEPARATOR)

all:					.print_header $(LIBFT) $(NAME)

make_libft:
							@$(MAKE) --silent -C $(LIBFT_DIR)

clean:					.print_header
							@printf "%$(SPACEMENT)b%b" "$(BLUE)[$(LIBFT_DIR)]:" "$(GREEN)[]$(DEF_COLOR)\n"
							@$(MAKE) --silent -C $(LIBFT_DIR) clean
							@printf "$(RED)=> Deleted!$(DEF_COLOR)\n"
							@printf "\n"
							@printf "%$(SPACEMENT)b%b" "$(BLUE)[$(OBJ_DIR)]:" "$(GREEN)[]$(DEF_COLOR)\n"
							@rm -rf $(OBJ_DIR)
							@printf "$(RED)=> Deleted!$(DEF_COLOR)\n"
							$(call SEPARATOR)

fclean: 				clean
							@printf "%$(SPACEMENT)b%b" "$(BLUE)[$(LIBFT_DIR)]:" "$(GREEN)[]$(DEF_COLOR)\n"
							@$(MAKE) --silent -C $(LIBFT_DIR) fclean
							@printf "$(RED)=> Deleted!$(DEF_COLOR)\n"
							@printf "\n"
							@printf "%$(SPACEMENT)b%b" "$(BLUE)[$(NAME)]:" "$(GREEN)[]$(DEF_COLOR)\n"
							@$(RM) $(NAME)
							@printf "$(RED)=> Deleted!$(DEF_COLOR)\n"
							$(call SEPARATOR)

re: 					.print_header fclean all

.PHONY: 				all make_libft clean fclean re

########################################################################################################################
#                                                       COMMANDS                                                       #
########################################################################################################################

$(NAME):				$(LIBFT) $(OBJ)
							@$(CC) $(CFLAGS) $(OBJ) $(LIBFT) -o $@ -lreadline

$(LIBFT):				make_libft

minishell_test:			$(LIBFT) $(TOBJ)
							@$(CC) $(CFLAGS) $(TOBJ) $(LIBFT) -o $@ -lreadline

$(OBJ_DIR)%.o: 			$(SRC_DIR)%.c $(INC_DIR)
							@mkdir -p $(dir $@)
							@$(CC) $(CFLAGS) -I$(INC_DIR) -I$(LIBFT_DIR)$(INC_DIR) -I$(INC_DIR) -c $< -o $@
							$(call PROGRESS_BAR_PERCENTAGE)
							$(if $(filter $(COMPILED_SRCS),$(SRCS_TO_COMPILE)),$(call SEPARATOR))

########################################################################################################################
#                                                       COLOURS                                                        #
########################################################################################################################

DEF_COLOR			:=	\033[0;39m
ORANGE				:=	\033[0;33m
GRAY				:=	\033[0;90m
RED					:=	\033[0;91m
GREEN				:=	\033[1;92m
YELLOW				:=	\033[1;93m
BLUE				:=	\033[0;94m
MAGENTA				:=	\033[0;95m
CYAN				:=	\033[0;96m
WHITE				:=	\033[0;97m

########################################################################################################################
#                                                       DISPLAY                                                        #
########################################################################################################################

SPACEMENT			:=	-41
COMPILED_SRCS		:=	0
FRAMES				:=	         
SLEEP_FRAME			:=	0.001

SRCS_TO_COMPILE		=	$(shell find $(SRC_DIR) -type f -name "*.c" -newer $(NAME) 2>/dev/null | wc -l)
ifeq ($(SRCS_TO_COMPILE),0)
	SRCS_TO_COMPILE =	$(shell find $(SRC_DIR) -type f -name "*.c" 2>/dev/null | wc -l)
endif

define PROGRESS_BAR_PERCENTAGE
						$(eval COMPILED_SRCS := $(shell expr $(COMPILED_SRCS) + 1))
						@if [ $(COMPILED_SRCS) -eq 1 ]; then \
							printf "$(BLUE)[$(NAME)]:$(DEF_COLOR)\n"; \
						fi
						@percentage=$$(if [ $(SRCS_TO_COMPILE) -eq 0 ]; then echo 0; else echo "scale=0; $(COMPILED_SRCS) * 100 / $(SRCS_TO_COMPILE)" | bc; fi); \
						for frame in $(FRAMES); do \
							printf "\r$$frame Compiling... [%d/%d] %d%%" $(COMPILED_SRCS) $(SRCS_TO_COMPILE) $$percentage; \
							sleep $(SLEEP_FRAME); \
						done; \
						if [ $(COMPILED_SRCS) -eq $(SRCS_TO_COMPILE) ]; then \
							printf "%-42b%b" "\r$(GREEN)Compilation finished [$(COMPILED_SRCS)/$(SRCS_TO_COMPILE)]" "$(GREEN)[]$(DEF_COLOR)\n"; \
						fi
endef

#TITLE ASCII ART - SLANT
define	DISPLAY_TITLE
						@echo "$(RED)		              _       _      __         ____"
						@echo "$(ORANGE)		   ____ ___  (_)___  (_)____/ /_  ___  / / /"
						@echo "$(YELLOW)		  / __ '__ \/ / __ \/ / ___/ __ \/ _ \/ / / "
						@echo "$(GREEN)		 / / / / / / / / / / (__  ) / / /  __/ / /  "
						@echo "$(BLUE)		/_/ /_/ /_/_/_/ /_/_/____/_/ /_/\___/_/_/   "
						@printf "$(PURPLE)		                                            $(DEF_COLOR)"
endef

define	SEPARATOR
						@printf "\n"
						@echo "$(ORANGE)--------------------------------------------------------------------------$(DEF_COLOR)";
						@printf "\n"
endef

define	BUILD
						@printf "%-47b%b" "$(GREEN)AUTHOR:$(DEF_COLOR)" "$(AUTHOR)\n";
						@printf "%-47b%b" "$(GREEN)NAME:$(DEF_COLOR)" "$(NAME)\n";
						@printf "%-47b%b" "$(GREEN)CC:$(DEF_COLOR)" "$(CC)\n";
						@printf "%-47b%b" "$(GREEN)FLAGS:$(DEF_COLOR)" "$(CFLAGS)\n";
endef

-include $(DEP)
</file>

<file path="readline.supp">
{
   Readline_All_Functions
   Memcheck:Leak
   ...
   obj:*/libreadline.so*
}
</file>

<file path="README.md">
<div align="center">
	<img src="https://github.com/ayogun/42-project-badges/raw/main/covers/cover-minishell-bonus.png" />
</div>

## Build

### Whole project

```sh
make
```
</file>

<file path="test_adv.sh">
#!/usr/bin/env bash

# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    minishell_advanced_test.sh                         :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: test_user <test@student.42.fr>             +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/03/17 10:00:00 by test_user         #+#    #+#              #
#    Updated: 2025/03/17 10:00:00 by test_user        ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# This script contains more advanced test cases for minishell
# It's designed to be used after the basic test script passes

# Colors for better output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Path to minishell
MINISHELL="./minishell_test"

# Count for tests
TOTAL_TESTS=0
PASSED_TESTS=0

# Function to print test description
print_test() {
  echo -e "${CYAN}Test #$TOTAL_TESTS: $1${NC}"
}

# Function to run a command manually with prompt
run_manual_test() {
  local cmd=$1
  local description=$2

  echo -e "\n${MAGENTA}=== MANUAL TEST ===${NC}"
  print_test "$description"
  echo -e "${YELLOW}Command to test: ${NC}$cmd"
  echo -e "${YELLOW}Press ENTER to run this test in minishell, then verify the behavior manually${NC}"
  read

  echo -e "${YELLOW}Running: $cmd${NC}"
  echo "$cmd" | "$MINISHELL"

  echo -e "${YELLOW}Did the test pass? (y/n)${NC}"
  read answer

  if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
    echo -e "${GREEN} PASS: $description${NC}"
    PASSED_TESTS=$((PASSED_TESTS + 1))
  else
    echo -e "${RED} FAIL: $description${NC}"
  fi
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
}

# Function to print section headers
print_header() {
  echo -e "\n${BLUE}======================================${NC}"
  echo -e "${BLUE}= $1${NC}"
  echo -e "${BLUE}======================================${NC}\n"
}

# Function to print the final summary
print_summary() {
  echo -e "\n${BLUE}======================================${NC}"
  echo -e "${BLUE}= SUMMARY${NC}"
  echo -e "${BLUE}======================================${NC}"
  echo -e "Total tests: $TOTAL_TESTS"
  echo -e "Passed: ${GREEN}$PASSED_TESTS${NC}"
  echo -e "Failed: ${RED}$((TOTAL_TESTS - PASSED_TESTS))${NC}"

  if [ $PASSED_TESTS -eq $TOTAL_TESTS ]; then
    echo -e "\n${GREEN}All tests passed! ${NC}"
  else
    echo -e "\n${RED}Some tests failed. ${NC}"
  fi
}

# Check if minishell executable exists
if [ ! -f "$MINISHELL" ]; then
  echo -e "${RED}Error: $MINISHELL not found. Make sure you are in the correct directory.${NC}"
  exit 1
fi

# Make sure we have the necessary permissions
chmod +x "$MINISHELL"

print_header "ADVANCED MINISHELL TESTING SCRIPT"
echo -e "${YELLOW}This script contains tests that require manual verification.${NC}"
echo -e "${YELLOW}Follow the instructions for each test carefully.${NC}"

# ===== INTERACTIVE SIGNAL TESTS =====
print_header "SIGNAL HANDLING TESTS"

echo -e "${YELLOW}The following tests will check signal handling in interactive mode.${NC}"
echo -e "${YELLOW}For each test, observe the behavior and compare it with bash.${NC}"

# Ctrl+C test (SIGINT)
run_manual_test "sleep 10" "Ctrl+C test: Run sleep 10, then press Ctrl+C - should interrupt and show a new prompt"

# Ctrl+D test (EOF)
run_manual_test "# Just press Ctrl+D when minishell starts" "Ctrl+D test: Press Ctrl+D at the prompt - should exit the shell"

# Ctrl+\ test (SIGQUIT)
run_manual_test "sleep 10" "Ctrl+\\ test: Run sleep 10, then press Ctrl+\\ - should do nothing"

# ===== EDGE CASES =====
print_header "EDGE CASES"

# Multiple pipes
run_manual_test "echo hello | cat | grep hello | tr 'a-z' 'A-Z'" "Multiple pipes: Should print HELLO"

# Multiple redirections
run_manual_test "echo hello > file1 > file2 > file3 && cat file3" "Multiple redirections: Should create 3 files and file3 should contain 'hello'"

# Nested quotes
run_manual_test "echo \"This is a 'nested' quote\"" "Nested quotes: Should print \"This is a 'nested' quote\""

# Empty command
run_manual_test "" "Empty command: Should just show a new prompt"

# Command with just spaces
run_manual_test "     " "Command with spaces: Should just show a new prompt"

# Redirections with no command
run_manual_test "> file.txt" "Redirection with no command: Should create an empty file"

# Heredoc with variable expansion
run_manual_test "cat << EOF\nHello \$USER\nEOF" "Heredoc with variable expansion: Should expand \$USER"

# Pipe with no command on right
run_manual_test "echo hello | " "Pipe with no right command: Should show an error"

# Pipe with no command on left
run_manual_test "| echo hello" "Pipe with no left command: Should show an error"

# ===== ERROR HANDLING =====
print_header "ERROR HANDLING"

# Command not found
run_manual_test "nonexistent_command" "Command not found: Should show an appropriate error message"

# Permission denied
run_manual_test "touch test_file.txt && chmod -x test_file.txt && ./test_file.txt" "Permission denied: Should show an appropriate error message"

# Directory as command
run_manual_test "mkdir -p test_dir && test_dir" "Directory as command: Should show an appropriate error message"

# Syntax error in quotes
run_manual_test "echo \"unclosed quote" "Unclosed quote: Should show an appropriate error message"

# ===== BONUS FEATURES =====
print_header "BONUS FEATURES"

# AND/OR operators
run_manual_test "true && echo success || echo failure" "AND/OR operators: Should print 'success'"
run_manual_test "false && echo success || echo failure" "AND/OR operators: Should print 'failure'"

# Parentheses for priorities
run_manual_test "(false || true) && echo success" "Parentheses priority: Should print 'success'"
run_manual_test "false || (true && echo success)" "Parentheses priority: Should print 'success'"

# Wildcards
run_manual_test "touch a.txt b.txt c.txt && echo *.txt" "Wildcard expansion: Should list all .txt files"

print_summary

# Clean up any files created during tests
rm -f test_file.txt file1 file2 file3 a.txt b.txt c.txt
rm -rf test_dir

exit 0
</file>

<file path="test.sh">
#!/usr/bin/env bash

# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    minishell_test.sh                                  :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: test_user <test@student.42.fr>             +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/03/17 10:00:00 by test_user         #+#    #+#              #
#    Updated: 2025/03/17 10:00:00 by test_user        ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# Colors for better output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

make minishell_test

# Path to minishell
MINISHELL="./minishell_test"

# Count for tests
TOTAL_TESTS=0
PASSED_TESTS=0

# Temporary files
EXPECTED_OUTPUT="/tmp/minishell_expected.txt"
ACTUAL_OUTPUT="/tmp/minishell_actual.txt"
ERROR_OUTPUT="/tmp/minishell_error.txt"
TEST_FILE="/tmp/minishell_test.txt"

# Check if minishell executable exists
if [ ! -f "$MINISHELL" ]; then
  echo -e "${RED}Error: $MINISHELL not found. Make sure you are in the correct directory.${NC}"
  exit 1
fi

# Make sure we have the necessary permissions
chmod +x "$MINISHELL"

# Function to print section headers
print_header() {
  echo -e "\n${BLUE}===============================================${NC}"
  echo -e "${BLUE}= $1${NC}"
  echo -e "${BLUE}===============================================${NC}\n"
}

# Function to print test description
print_test() {
  echo -e "${CYAN}Test #$TOTAL_TESTS: $1${NC}"
}

# Function to check if the test passed or failed
check_result() {
  local result=$1
  local description=$2

  if [ $result -eq 0 ]; then
    echo -e "${GREEN} PASS: $description${NC}"
    PASSED_TESTS=$((PASSED_TESTS + 1))
  else
    echo -e "${RED} FAIL: $description${NC}"
    if [ -n "$3" ]; then
      echo -e "${YELLOW}$3${NC}"
    fi
  fi
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
}

# Function to run a command and compare its output
run_test() {
  local cmd=$1
  local expected_output=$2
  local description=$3

  print_test "$description"

  # Write expected output to file with newline (matching echo behavior)
  echo "$expected_output" >"$EXPECTED_OUTPUT"

  # Run the command in minishell
  echo "$cmd" | "$MINISHELL" 2>"$ERROR_OUTPUT" | grep -v "^$" | grep -v "^\$" | tr -d '\r' >"$ACTUAL_OUTPUT"

  # For debugging - show what's in the files
  echo "Debug - Expected output:" >>"$ERROR_OUTPUT"
  hexdump -C "$EXPECTED_OUTPUT" >>"$ERROR_OUTPUT"
  echo "Debug - Actual output:" >>"$ERROR_OUTPUT"
  hexdump -C "$ACTUAL_OUTPUT" >>"$ERROR_OUTPUT"

  # Compare outputs (ignore empty lines and prompt)
  diff "$EXPECTED_OUTPUT" "$ACTUAL_OUTPUT" >/dev/null
  local result=$?

  local error_msg=""
  if [ $result -ne 0 ]; then
    error_msg="Expected: \"$expected_output\"\nActual: \"$(cat "$ACTUAL_OUTPUT")\""
    if [ -s "$ERROR_OUTPUT" ]; then
      error_msg="$error_msg\nError: \"$(cat "$ERROR_OUTPUT")\""
    fi
  fi

  check_result $result "$description" "$error_msg"
}

# Function to run a command with exit status check
run_test_exit_status() {
  local cmd=$1
  local expected_status=$2
  local description=$3

  print_test "$description"

  # Run the command in minishell and capture exit status
  echo "$cmd" | "$MINISHELL" >/dev/null 2>&1
  echo "echo \$?" | "$MINISHELL" >"$ACTUAL_OUTPUT" 2>/dev/null

  # Get the actual status
  local actual_status=$(grep -v "^\$" "$ACTUAL_OUTPUT" | tail -1)

  local result=1
  if [ "$actual_status" -eq "$expected_status" ]; then
    result=0
  fi

  local error_msg=""
  if [ $result -ne 0 ]; then
    error_msg="Expected exit status: $expected_status, Actual: $actual_status"
  fi

  check_result $result "$description" "$error_msg"
}

# Function to run a test on command execution (without output comparison)
run_command_test() {
  local cmd=$1
  local description=$2

  print_test "$description"

  # Run the command in minishell
  echo "$cmd" | "$MINISHELL" >/dev/null 2>&1
  local result=$?

  check_result 0 "$description" # Assume success unless it crashes
}

# Function to check if a file exists after a command
check_file_existence() {
  local cmd=$1
  local file=$2
  local should_exist=$3 # 1 for should exist, 0 for should not exist
  local description=$4

  print_test "$description"

  # Run the command in minishell
  echo "$cmd" | "$MINISHELL" >/dev/null 2>&1

  # Check if file exists
  if [ -e "$file" ]; then
    file_exists=1
  else
    file_exists=0
  fi

  local result=1
  if [ "$file_exists" -eq "$should_exist" ]; then
    result=0
  fi

  local error_msg=""
  if [ $result -ne 0 ]; then
    if [ "$should_exist" -eq 1 ]; then
      error_msg="File $file does not exist but should."
    else
      error_msg="File $file exists but should not."
    fi
  fi

  check_result $result "$description" "$error_msg"

  # Clean up the file if it exists
  if [ -e "$file" ]; then
    rm -f "$file"
  fi
}

# Function to print the final summary
print_summary() {
  echo -e "\n${BLUE}======================================${NC}"
  echo -e "${BLUE}= SUMMARY${NC}"
  echo -e "${BLUE}======================================${NC}"
  echo -e "Total tests: $TOTAL_TESTS"
  echo -e "Passed: ${GREEN}$PASSED_TESTS${NC}"
  echo -e "Failed: ${RED}$((TOTAL_TESTS - PASSED_TESTS))${NC}"

  if [ $PASSED_TESTS -eq $TOTAL_TESTS ]; then
    echo -e "\n${GREEN}All tests passed! ${NC}"
  else
    echo -e "\n${RED}Some tests failed. ${NC}"
  fi
}

# Function to set up the test environment
setup() {
  # Create test files
  echo "test file content" >"$TEST_FILE"
}

# Function to clean up after tests
cleanup() {
  # Remove temporary files
  rm -f "$EXPECTED_OUTPUT" "$ACTUAL_OUTPUT" "$ERROR_OUTPUT" "$TEST_FILE"

  # Clean up any files that may have been created during tests
  rm -f output.txt input.txt test_file.txt
}

# Main test function
run_tests() {
  print_header "MINISHELL TESTING SCRIPT"

  # ===== BASIC COMMANDS =====
  print_header "BASIC COMMANDS"

  run_test "echo Hello" "Hello" "Simple echo command"
  run_test "echo -n Hello" "Hello" "Echo with -n option"
  run_test "pwd" "$(pwd)" "PWD command"
  run_test "echo \$PWD" "$(pwd)" "Environment variable in echo"

  # ===== ENVIRONMENT VARIABLES =====
  print_header "ENVIRONMENT VARIABLES"

  run_test "export TEST_VAR=hello && echo \$TEST_VAR" "hello" "Set and echo environment variable"
  run_test "export TEST_VAR=hello && unset TEST_VAR && echo \$TEST_VAR" "" "Unset environment variable"
  run_test "echo \$?" "0" "Echo exit status after successful command"
  run_test "nonexistent_command 2>/dev/null || echo \$?" "127" "Echo exit status after command not found"

  # ===== BUILTINS =====
  print_header "BUILTIN COMMANDS"

  # CD tests
  current_dir=$(pwd)
  run_command_test "cd /tmp && pwd" "CD to absolute path"
  run_command_test "cd $current_dir" "CD back to original directory"
  run_command_test "cd .. && pwd" "CD to parent directory"
  run_command_test "cd $current_dir" "CD back to original directory again"

  # ENV test
  run_command_test "env | grep -q PATH" "ENV command shows PATH"

  # EXPORT and UNSET tests
  run_test "export TEST_VAR=value && echo \$TEST_VAR" "value" "EXPORT sets variable"
  run_test "unset TEST_VAR && echo \$TEST_VAR" "" "UNSET removes variable"

  # EXIT test
  # Note: We can't directly test exit as it would terminate the script
  run_command_test "echo 'exit status test'" "Exit command recognized (indirect test)"

  # ===== QUOTES =====
  print_header "QUOTES HANDLING"

  run_test "echo 'single quotes'" "single quotes" "Single quotes"
  run_test "echo \"double quotes\"" "double quotes" "Double quotes"
  run_test "echo 'mixed \"quotes\"'" "mixed \"quotes\"" "Mixed quotes (single outside)"
  run_test "echo \"mixed 'quotes'\"" "mixed 'quotes'" "Mixed quotes (double outside)"
  run_test "echo \"variable \$USER expansion\"" "variable $USER expansion" "Variable expansion in double quotes"
  run_test "echo 'no \$USER expansion'" "no \$USER expansion" "No variable expansion in single quotes"

  # ===== REDIRECTIONS =====
  print_header "REDIRECTIONS"

  # Output redirection >
  check_file_existence "echo output > output.txt" "output.txt" 1 "Output redirection >"

  # Output redirection >>
  check_file_existence "echo first > output.txt && echo second >> output.txt" "output.txt" 1 "Output redirection >>"

  # Input redirection <
  check_file_existence "echo input data > input.txt && cat < input.txt > output.txt" "output.txt" 1 "Input redirection <"

  # Heredoc <<
  check_file_existence "cat << EOF > output.txt\nHeredoc test\nEOF" "output.txt" 1 "Heredoc <<"

  # ===== PIPES =====
  print_header "PIPES"

  run_test "echo hello | cat" "hello" "Simple pipe"
  run_test "echo hello | grep hello" "hello" "Pipe with grep"
  run_test "echo hello | grep world || echo not found" "not found" "Pipe with grep (not found)"
  run_test "echo hello | tr 'a-z' 'A-Z'" "HELLO" "Pipe with tr"
  run_test "echo hello | tr 'a-z' 'A-Z' | sed 's/H/h/'" "hELLO" "Multiple pipes"

  # ===== SIGNAL HANDLING =====
  print_header "SIGNAL HANDLING (Interactive Mode Simulation)"

  # Note: We can't really test signal handling in a script like this.
  # We'll just make sure the shell doesn't crash when we try common signals
  echo -e "${YELLOW}Signal handling tests should be performed manually.${NC}"
  echo -e "${YELLOW}Try pressing Ctrl+C, Ctrl+D, and Ctrl+\\ in the shell and observe behavior.${NC}"

  # ===== BONUS FEATURES =====
  print_header "BONUS FEATURES (if implemented)"

  # && and || operators with parenthesis
  run_test "echo success && echo another success" "success\nanother success" "AND operator &&"
  run_test "false || echo fallback" "fallback" "OR operator ||"

  # Wildcards (this test depends on files in the current directory)
  run_command_test "ls *.sh > /dev/null 2>&1" "Wildcard * expansion"

  print_header "COMPLEX COMMANDS"

  # Complex command combinations
  run_command_test "export TEST=hello && echo \$TEST | tr 'a-z' 'A-Z' > output.txt && cat output.txt" "Complex command with export, pipe, and redirection"
  run_command_test "cat < input.txt | grep test > output.txt 2>/dev/null || echo 'Not found'" "Complex command with input, pipe, output and error redirections"

  # Print summary
  print_summary
}

# Run the whole test suite
setup
run_tests
cleanup

exit 0
</file>

</files>
