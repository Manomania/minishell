This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-21T08:24:23.750Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
include/
  debug.h
  error.h
  memory.h
  minishell.h
  validation.h
src/
  builtins/
    builtins_try.c
  command/
    command_add.c
    command_bin.c
    command_execute_utils.c
    command_execute.c
    command_new.c
    command_parse.c
    command_redirections.c
  debug/
    debug_utils.c
    debug.c
  env/
    env_find_bin.c
    env_find.c
    env_quotes.c
    env.c
  error/
    ctx_error_exit.c
    error_utils.c
    error.c
  exec/
    exec_cmdas_utils.c
    exec_cmdas_utils2.c
    exec_cmdas.c
  free/
    ctx_exit.c
    free_2d_array.c
    free_command.c
    free_ctx.c
    free_env.c
    pipes_utils.c
  init/
    init_ctx.c
    init_parse.c
  lexer/
    lexer_read_utils.c
    lexer_read.c
    lexer_token_is.c
    lexer_token_utils.c
    lexer_token.c
    lexer_tokenize.c
    lexer_utils.c
  memory/
    memory.c
  parser/
    parser_command.c
    parser_pipeline.c
    parser_utils.c
  path/
    bin_find_path.c
    bin_find.c
  redir/
    heredoc.c
    redirections.c
  signals/
    signals.c
  test/
    main.c
  validation/
    validation.c
  main_utils.c
  main.c
.editorconfig
.gitignore
.gitmodules
.repomixignore
readline.supp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="include/debug.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:36:58 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:37:03 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef DEBUG_H
# define DEBUG_H

# include "minishell.h"

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define DEBUG_NONE 0
# define DEBUG_ERROR 1
# define DEBUG_INFO 2
# define DEBUG_VERBOSE 3

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// global variable
extern int	g_debug_level;

// debug.c
void	debug_init(int level);
void	debug_print_token(int level, t_token *token);
void	debug_print_tokens(int level, t_token *tokens);
void	debug_print_command(int level, t_command *cmd);
void	debug_print_commands(int level, t_command *cmd);
void	debug_log(int level, const char *module, const char *msg);

#endif
</file>

<file path="include/error.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:32:19 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:45:16 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ERROR_H
# define ERROR_H

# include "minishell.h"

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

typedef enum e_error_level
{
	INFO,
	WARNING,
	ERROR,
	FATAL
}	t_error_level;

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// ctx_error_exit.c
void			ctx_error_exit(t_ctx *ctx, t_error_type err);

// error.c
int				error_code(t_error_type err);
void			error_print(t_error_level level, const char *module, const char *msg);

// error_utils.c
t_error_info	*get_error_table(void);
int				ctx_error(t_error_type err);
int				ctx_error_level(t_error_type err, t_error_level level);
void			error_exit(t_ctx *ctx, t_error_type err, const char *module);

#endif
</file>

<file path="include/memory.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:33:40 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:33:44 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MEMORY_H
# define MEMORY_H

# include "minishell.h"

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// memory.c
char	*safe_strdup(t_ctx *ctx, const char *str, const char *module);
char	*safe_strjoin(t_ctx *ctx, const char *s1, const char *s2,
			const char *module);
void	*safe_malloc(t_ctx *ctx, size_t size, const char *module);
void	*safe_calloc(t_ctx *ctx, size_t nmemb, size_t size, const char *module);

#endif
</file>

<file path="include/minishell.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 17:15:54 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 18:37:49 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft.h"
# include <errno.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/types.h>
# include <sys/wait.h>

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define RESET "\033[039m"
# define RED "\033[091m"
# define BLUE "\033[034m"
# define GREEN "\033[092m"
# define YELLOW "\033[093m"
# define MAGENTA "\033[35m"
# define CYAN "\033[36m"

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

typedef enum e_bool
{
	false,
	true,
}							t_bool;

typedef enum e_token_type
{
	TOK_WORD,          // Commands, args, filename
	TOK_OPEN_PAR,      // (
	TOK_CLOSE_PAR,     // )
	TOK_REDIR_FROM,    // <
	TOK_REDIR_TO,      // >
	TOK_HERE_DOC_FROM, // <<
	TOK_HERE_DOC_TO,   // >>
	TOK_PIPE,          // |
	TOK_ENV,           // $
	TOK_AND,           // &&
	TOK_OR,            // ||
	TOK_NEW_LINE,      // \n
	TOK_EOF,           // '\0'
}							t_token_type;

typedef struct s_token
{
	t_token_type			type;
	struct s_token			*next;
	char					*value;
}							t_token;

typedef struct s_lexer
{
	char					*input;
	int						position;
	int						length;
}							t_lexer;

/**
 * @brief Represents a command redirection (input/output)
 */
typedef struct s_redirection
{
	t_token_type			type;
	struct s_redirection	*next;
	int						fd;
	char					*filename;
}							t_redirection;

/**
 * @brief Represents a single command with its arguments and redirections
 */
typedef struct s_command
{
	t_token_type			operator;
	t_redirection			*redirection;
	struct s_command		*next;
	char					**args;
	int						arg_count;
}							t_command;

typedef struct s_parse
{
	t_token					*token;
	t_token					*current;
}							t_parse;

typedef struct s_env
{
	struct s_env			*next;
	char					*key;
	char					*value;
}							t_env;

typedef enum e_error_type
{
	ERR_NONE = 0,
	ERR_CMD_NOT_FOUND,
	ERR_NO_PERMISSION,
	ERR_IO_ERROR,
	ERR_UNIMPLEMENTED,
	ERR_ALLOC,
	ERR_PIPE,
	ERR_CHILD,
	ERR_NO_SUCH_FILE,
}							t_error_type;

typedef struct s_error_info
{
	int						code;
	const char				*message;
	t_bool					use_perror;
}							t_error_info;

/**
 * @brief Represents a parsed token
 */
typedef struct s_ctx
{
	t_env					*env_list;
	int						exit_status;
	t_bool					exit_requested;
	int						interactive;
	int						argc;
	char					**argv;
	char					**envp;
	t_token					*tokens;
	t_command				*cmd;
	int						fd_file_in;
	int						fd_file_out;
}							t_ctx;

typedef struct s_quote_state
{
	int						in_single_quote;
	int						in_double_quote;
}							t_quote_state;

/**
 * @brief Structure to hold pipeline process data
 */
typedef struct s_pipe_data
{
	t_command				*current;
	int						cmd_count;
	int						i;
	int						prev_pipe;
	pid_t					*pids;
	int						pipe_fds[2];
}							t_pipe_data;

/**
 * @brief Simple enum proper error handling in bin_find.c
 */
typedef enum e_path_error
{
	PATH_ERR_NONE,
	PATH_ERR_NOT_FOUND,
	PATH_ERR_NO_PERMISSION,
	PATH_ERR_OTHER
}							t_path_error;

// *************************************************************************** #
//                            Function Prototypes                              #
// *************************************************************************** #

// builtins_try.c
t_bool						builtins_try(t_ctx *ctx, t_command *cmd);

// command_add.c
int							command_add_argument(t_command *cmd, char *arg);
int							command_add_redirection(t_command *cmd,
								t_token_type type, int fd, char *filename);

// command_bin.c
t_bool						command_bin(t_ctx *ctx);

// command_execute.c
int							command_execute(t_ctx *ctx);

// command_execute_utils.c
int							get_exit_status(int status);
void						execute_child(t_ctx *ctx);

// command_new.c
t_command					*command_new(void);

// command_parse.c
t_command					*command_parse(t_ctx *ctx, t_token *tokens);

// command_redirection.c
int							handle_redirections(t_redirection *redirections);

// debug_utils.c
void						print_tokens(t_token *tokens);

// env.c
char						*expand_var(t_ctx *ctx, char *var_name);
char						*append_part(char *result, char *str, int start,
								int end);
char						*expand_variable(t_ctx *ctx, char *str, int *i,
								int in_squote);

// env_find.c
char						*env_find(t_ctx *ctx, char *var);

// env_find_bin.c
char						*env_find_bin(t_ctx *ctx, char *bin);

// env_quotes
char						*handle_quotes_and_vars(t_ctx *ctx, char *str);

// exec_cmdas.c
int							exec_cmdas(t_ctx *ctx);

// exec_cmdas_utils.c
pid_t						exec_piped_command(t_ctx *ctx, t_command *cmd,
								int input_fd, int output_fd);
int							setup_pipe(int pipe_fds[2]);
int							wait_for_pids(pid_t *pids, int count);

// exec_cmdas_utils2.c
int							count_commands(t_command *cmd);
void						setup_child_process(t_ctx *ctx, t_command *cmd,
								int input_fd, int output_fd);

// ctx_exit.c
void						ctx_exit(t_ctx *ctx);

// free_2d_array.c
void						free_2d_array(void **ptrs);

// free_commands.c
void						free_command(t_command *cmd);
void						free_all_commands(t_command *cmd);

// free_ctx.c
void						ctx_clear(t_ctx *ctx);

// free_env.c
void						free_env_list(t_env *env_list);
int							parse_env_var(char *env_str, t_env **env_list);

// init_ctx.c
t_ctx						*init_ctx(int argc, char **argv, char **envp);
int							add_env_var(t_env **env_list, char *key,
								char *value);

// init_parse.c
t_command					*create_command(void);
t_token						*create_token(t_token_type type, char *value);
t_redirection				*create_redirection(t_token_type type,
								char *filename);
void						init_parse_context(t_parse *parse, t_token *token);

// lexer_read.c
char						*read_word_lexer(t_lexer *lexer);
char						*read_complex_word(t_lexer *lexer);
char						*read_quoted_string_lexer(t_lexer *lexer,
								char quote_char);

// lexer_read_utils.c
char						*join_and_free(char *s1, char *s2);
char						*handle_dollar_sign(char *result);
char						*handle_word_part(t_lexer *lexer, char *result);
char						*handle_quoted_part(t_lexer *lexer, char *result,
								char quote_char);

// lexer_token.c
t_token						*next_token_lexer(t_lexer *lexer);
void						free_all_token(t_token *token);

// lexer_token_is.c
t_bool						token_is_redirection(t_token_type type);

// lexer_token_utils.c
t_token						*handle_basics_token(t_lexer *lexer);
t_token						*handle_pipe_and_token(t_lexer *lexer);
t_token						*handle_redir_from_and_to_token(t_lexer *lexer);
t_token						*handle_env_token(t_lexer *lexer);

// lexer_tokenize.c
t_token						*tokenize(t_ctx *ctx, char *input);

// lexer_utils.c
char						get_lexer(t_lexer *lexer);
void						advance_lexer(t_lexer *lexer);
void						skip_whitespace_lexer(t_lexer *lexer);

// parser_utils.c
char						*get_token_value(t_parse *parse);
int							check_parse(t_parse *parse, t_token_type type);
int							consume_parse(t_parse *parse, t_token_type type);
int							check_token_type(t_parse *parse, t_token_type type);
void						advance_parse(t_parse *parse);

// bin_find.c
char						*bin_find(t_ctx *ctx, char *bin);

// bin_find_path.c
char						*bin_find_path(const char *dir, char *bin);

// heredoc.c
int							setup_heredocs(t_ctx *ctx, t_command *cmd);

// redirections.c
int							setup_redirections(t_redirection *redirections);

// signals.c
void						setup_signals(void);
void						reset_signals(void);
void						setup_parent_signals(void);

// main.c
// A REMPLIR

// main_utils.c
char						*get_user_input(t_ctx *ctx, int prev_status);

// A REMPLACER EN FONCTION SI TU UTILISES MES FONCTIONS
// // parser_command.c
t_command					*parse_command(t_parse *parse, t_ctx *ctx);
// int				parse_redirection(t_parse *parse, t_command *cmd,
// 					t_ctx *ctx);
// void			add_redirection(t_command *cmd, t_redirection *redirection);
//
// // parser_pipeline.c
// t_command		*parse_pipeline(t_ctx *ctx, t_parse *parse);
// t_command		*parse_command_sequence(t_ctx *ctx, t_parse *parse);

#endif
</file>

<file path="include/validation.h">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.h                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:39:18 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:39:19 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef VALIDATION_H
# define VALIDATION_H

# include "minishell.h"

// *************************************************************************** #
//                                   Macros                                    #
// *************************************************************************** #

# define MAX_INPUT_LEN		4096
# define MAX_VAR_NAME_LEN	255

// *************************************************************************** #
//                                 Structures                                  #
// *************************************************************************** #

t_bool	validate_command(t_command *cmd, t_ctx *ctx);
t_bool	validate_env_var_name(char *name, t_ctx *ctx);
t_bool	validate_filename(char *filename, t_ctx *ctx);
t_bool	validate_input_length(char *input, t_ctx *ctx);

#endif
</file>

<file path="src/builtins/builtins_try.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_try.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 12:19:14 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:34:16 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Tries to execute a builtin command
 *
 * @param ctx Context for shell environment
 * @param cmd Command to check for builtin
 * @return t_bool true if builtin was executed, false otherwise
 */
t_bool	builtins_try(t_ctx *ctx, t_command *cmd)
{
	char	cmd_name[64];
	int		exit_code;

	if (!ctx || !cmd || !cmd->args || !cmd->args[0])
	{
		error_print(ERROR, "builtin", "Invalid command");
		return (false);
	}
	ft_strlcpy(cmd_name, "Checking builtin: ", sizeof(cmd_name));
	ft_strlcat(cmd_name, cmd->args[0], sizeof(cmd_name));
	debug_log(DEBUG_INFO, "builtin", cmd_name);
	if (ft_strncmp(cmd->args[0], "exit", __INT_MAX__) == 0)
	{
		debug_log(DEBUG_INFO, "builtin", "Executing exit builtin");
		exit_code = 0;
		if (cmd->arg_count >= 1 && cmd->args[1])
			exit_code = ft_atoi(cmd->args[1]);
		ctx->exit_status = exit_code;
		ctx->exit_requested = true;
		return (true);
	}
	debug_log(DEBUG_INFO, "builtin", "No matching builtin found");
	return (false);
}
</file>

<file path="src/command/command_add.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_add.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:48:41 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:41:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Allocates and copies arguments to a new array
 *
 * @param cmd Command containing the arguments
 * @param new_size Size of the new array to allocate
 * @return char** New array of arguments or NULL on failure
 */
static char	**allocate_args_array(t_command *cmd, int new_size)
{
	char	**new_args;
	int		i;

	new_args = (char **)malloc(sizeof(char *) * (size_t)new_size);
	if (!new_args)
		return (NULL);
	i = 0;
	while (i < cmd->arg_count + 1)
	{
		new_args[i] = cmd->args[i];
		i++;
	}
	new_args[i] = NULL;
	new_args[new_size - 1] = NULL;
	return (new_args);
}

/**
 * @brief Adds an argument to a command
 * Arguments are stored in args array starting at index 1
 * args[0] is always the command name
 *
 * @param cmd Command to add argument to
 * @param arg Argument string to add
 * @return int 0 on success, -1 on failure
 */
int	command_add_argument(t_command *cmd, char *arg)
{
	char	**new_args;
	char	*arg_copy;

	if (!cmd || !arg)
		return (-1);
	new_args = allocate_args_array(cmd, cmd->arg_count + 3);
	if (!new_args)
		return (-1);
	arg_copy = ft_strdup(arg);
	if (!arg_copy)
	{
		free(new_args);
		return (-1);
	}
	new_args[cmd->arg_count + 1] = arg_copy;
	if (cmd->args)
		free(cmd->args);
	cmd->args = new_args;
	cmd->arg_count++;
	return (0);
}

/**
 * @brief Adds a redirection to a command
 *
 * @param cmd Command to add redirection to
 * @param type Redirection type (< > << >>)
 * @param fd File descriptor (0 for input, 1 for output)
 * @param filename Target filename
 * @return int 0 on success, -1 on failure
 */
int	command_add_redirection(t_command *cmd, t_token_type type, int fd,
		char *filename)
{
	t_redirection	*redir;
	t_redirection	*current;

	if (!cmd || !filename)
		return (-1);
	redir = malloc(sizeof(t_redirection));
	if (!redir)
		return (-1);
	redir->type = type;
	redir->fd = fd;
	redir->filename = ft_strdup(filename);
	if (!redir->filename)
		return (free(redir), -1);
	redir->next = NULL;
	if (!cmd->redirection)
		cmd->redirection = redir;
	else
	{
		current = cmd->redirection;
		while (current->next)
			current = current->next;
		current->next = redir;
	}
	return (0);
}
</file>

<file path="src/command/command_bin.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_bin.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 18:52:18 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:25:08 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Finds the binary path and updates the command arg
 *
 * @param ctx Context
 * @return t_bool true if successful, false otherwise
 */
t_bool	command_bin(t_ctx *ctx)
{
	char	*bin_og;
	char	*bin;

	if (!ctx->cmd->args || !ctx->cmd->args[0])
		return (false);
	bin_og = ctx->cmd->args[0];
	bin = bin_find(ctx, bin_og);
	if (!bin)
	{
		free(bin_og);
		ctx->cmd->args[0] = NULL;
		return (false);
	}
	free(bin_og);
	ctx->cmd->args[0] = bin;
	return (true);
}
</file>

<file path="src/command/command_execute_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_execute_utils.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:54:30 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:22:55 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Sets up child process redirections
 *
 * This function handles heredocs and redirections in the child process.
 *
 * @param ctx Context with environment information
 * @param cmd Command containing redirections
 * @return 0 on success, non-zero on error
 */
static int	setup_child_redirections(t_ctx *ctx, t_command *cmd)
{
	int	result;

	result = setup_heredocs(ctx, cmd);
	if (result != 0)
		return (result);
	result = setup_redirections(cmd->redirection);
	return (result);
}

/**
 * @brief Checks if command exists and is executable
 *
 * This function verifies the command path and permissions.
 *
 * @param cmd Command to check
 * @return 0 on success, non-zero on error
 */
static int	check_command_executable(t_command *cmd)
{
	if (!cmd->args[0] || access(cmd->args[0], X_OK) != 0)
	{
		ft_printf("command not found or not executable: %s\n", cmd->args[0]);
		return (1);
	}
	return (0);
}

/**
 * @brief Executes the child process portion of a single command
 *
 * This function handles the execution of a command in a child process.
 *
 * @param ctx Context containing environment and command info
 */
void	execute_child(t_ctx *ctx)
{
	int	redirect_result;
	int	cmd_check;

	reset_signals();
	redirect_result = setup_child_redirections(ctx, ctx->cmd);
	if (redirect_result != 0)
		exit(EXIT_FAILURE);
	cmd_check = check_command_executable(ctx->cmd);
	if (cmd_check != 0)
		exit(EXIT_FAILURE);
	execve(ctx->cmd->args[0], ctx->cmd->args, ctx->envp);
	perror("execve");
	exit(EXIT_FAILURE);
}

/**
 * @brief Gets the exit status from process termination information
 *
 * This function extracts the exit status from the process status.
 *
 * @param status Process status from waitpid
 * @return Exit status of the process
 */
int	get_exit_status(int status)
{
	int	exit_code;

	if (WIFEXITED(status))
	{
		exit_code = WEXITSTATUS(status);
		debug_log(DEBUG_VERBOSE, "exit_status", "Process exited normally");
		return (exit_code);
	}
	if (WIFSIGNALED(status))
	{
		exit_code = 128 + WTERMSIG(status);
		debug_log(DEBUG_VERBOSE, "exit_status", "Process terminated by signal");
		return (exit_code);
	}
	debug_log(DEBUG_VERBOSE, "exit_status", "Process ended in unknown state");
	return (1);
}
</file>

<file path="src/command/command_execute.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_execute.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 16:10:59 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:37:17 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Executes a single command without a pipeline
 *
 * This function executes a single command by forking a child process.
 *
 * @param ctx Context containing environment and command info
 * @return Exit status of the command
 */
static int	execute_single_command(t_ctx *ctx)
{
	pid_t	pid;
	int		status;

	if (!command_bin(ctx))
	{
		if (ctx->cmd->args && ctx->cmd->args[0] && (ft_strchr(ctx->cmd->args[0],
					'/') || ctx->cmd->args[0][0] == '.'))
			return (2);
		return (error_code(ERR_CMD_NOT_FOUND));
	}
	setup_parent_signals();
	pid = fork();
	if (pid == -1)
		return (ctx_error(ERR_CHILD));
	if (pid == 0)
		execute_child(ctx);
	waitpid(pid, &status, 0);
	setup_signals();
	return (get_exit_status(status));
}

/**
 * @brief Checks if the command is part of a pipeline
 *
 * This function determines if a command is part of a pipeline.
 *
 * @param cmd Command to check
 * @return true if command is part of pipeline, false otherwise
 */
static t_bool	is_pipeline(t_command *cmd)
{
	return (cmd && cmd->next);
}

/**
 * @brief Executes a command or pipeline
 *
 * @param ctx Context containing environment and command info
 * @return Exit status of the command
 */
int	command_execute(t_ctx *ctx)
{
	int	status;

	if (!ctx || !ctx->cmd)
	{
		status = ctx_error(ERR_ALLOC);
		ctx->exit_status = status;
		return (status);
	}
	if (!ctx->cmd->args || !ctx->cmd->args[0])
	{
		ctx->exit_status = -1;
		return (-1);
	}
	debug_log(DEBUG_INFO, "execute", "Executing command");
	if (builtins_try(ctx, ctx->cmd))
		return (ctx->exit_status);
	if (is_pipeline(ctx->cmd))
	{
		debug_log(DEBUG_INFO, "execute", "Pipeline detected");
		status = exec_cmdas(ctx);
	}
	else
		status = execute_single_command(ctx);
	ctx->exit_status = status;
	return (status);
}
</file>

<file path="src/command/command_new.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_new.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:48:09 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/13 11:47:37 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Creates a new command structure
 *
 * @return t_command* New initialized command or NULL if allocation fails
 */
t_command	*command_new(void)
{
	t_command	*cmd;

	cmd = (t_command *)malloc(sizeof(t_command));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->arg_count = 0;
	cmd->redirection = NULL;
	cmd->next = NULL;
	return (cmd);
}
</file>

<file path="src/command/command_parse.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_parse.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:46:45 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 17:02:35 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Processes a word token during command parsing
 *
 * @param cmd Command structure being built
 * @param token Current token being processed
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_word_token(t_command *cmd, t_token *token, t_ctx *ctx)
{
	char	*expanded_value;

	if (!cmd->args)
	{
		cmd->args = malloc(sizeof(char *) * 2);
		if (!cmd->args)
			return (false);
		expanded_value = handle_quotes_and_vars(ctx, token->value);
		if (!expanded_value)
		{
			free(cmd->args);
			cmd->args = NULL;
			return (false);
		}
		cmd->args[0] = expanded_value;
		cmd->args[1] = NULL;
		cmd->arg_count = 0;
	}
	else
	{
		expanded_value = handle_quotes_and_vars(ctx, token->value);
		if (command_add_argument(cmd, expanded_value) != 0)
		{
			free(expanded_value);
			return (false);
		}
		free(expanded_value);
	}
	return (true);
}

/**
 * @brief Processes an environment variable token during command parsing
 *
 * @param cmd Command structure being built
 * @param token Current token being processed
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_env_token(t_command *cmd, t_token *token, t_ctx *ctx)
{
	char	*expanded_value;

	expanded_value = expand_var(ctx, token->value);
	if (!expanded_value)
		return (false);
	if (!cmd->args)
	{
		cmd->args = malloc(sizeof(char *) * 2);
		if (!cmd->args)
		{
			free(expanded_value);
			return (false);
		}
		cmd->args[0] = expanded_value;
		cmd->args[1] = NULL;
		cmd->arg_count = 0;
	}
	else
	{
		if (command_add_argument(cmd, expanded_value) != 0)
		{
			free(expanded_value);
			return (false);
		}
		free(expanded_value);
	}
	return (true);
}

/**
 * @brief Processes a redirection token during command parsing
 *
 * @param cmd Command to add redirection to
 * @param token Current redirection token
 * @param next_token The next token (containing filename)
 * @param ctx Context containing environment information
 * @return int 0 on success, -1 on failure
 */
static int	handle_redirection_token(t_command *cmd, t_token *token,
		t_token *next_token, t_ctx *ctx)
{
	int		fd;
	int		result;
	char	*expanded_filename;

	if (!cmd || !token || !next_token)
		return (-1);
	if (next_token->type != TOK_WORD && next_token->type != TOK_ENV)
		return (-1);
	fd = 1;
	if (token->type == TOK_REDIR_FROM || token->type == TOK_HERE_DOC_FROM)
		fd = 0;
	if (next_token->type == TOK_ENV)
		expanded_filename = expand_var(ctx, next_token->value);
	else
		expanded_filename = handle_quotes_and_vars(ctx, next_token->value);
	if (!expanded_filename)
		return (-1);
	result = command_add_redirection(cmd, token->type, fd, expanded_filename);
	free(expanded_filename);
	return (result);
}

/**
 * @brief Processes tokens until end of command or pipeline marker
 *
 * @param current Current token pointer reference
 * @param cmd Current command being built
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	process_command_tokens(t_token **current, t_command *cmd,
		t_ctx *ctx)
{
	while (*current && (*current)->type != TOK_PIPE)
	{
		if ((*current)->type == TOK_WORD)
		{
			if (!process_word_token(cmd, *current, ctx))
				return (false);
		}
		else if ((*current)->type == TOK_ENV)
		{
			if (!process_env_token(cmd, *current, ctx))
				return (false);
		}
		else if (token_is_redirection((*current)->type))
		{
			if ((*current)->next && handle_redirection_token(cmd, *current,
					(*current)->next, ctx) == -1)
				return (false);
			if ((*current)->next)
				*current = (*current)->next;
		}
		if (*current)
			*current = (*current)->next;
	}
	return (true);
}

/**
 * @brief Creates commands for a pipeline of commands
 *
 * @param cmd Current command pointer reference
 * @param current Current token pointer reference
 * @param ctx Context containing environment information
 * @return t_bool true on success, false on failure
 */
static t_bool	create_pipeline(t_command **cmd, t_token **current, t_ctx *ctx)
{
	t_command	*new_cmd;

	if (*current && (*current)->type == TOK_PIPE)
	{
		new_cmd = command_new();
		if (!new_cmd)
			return (false);
		(*cmd)->next = new_cmd;
		*cmd = new_cmd;
		*current = (*current)->next;
		if (!process_command_tokens(current, *cmd, ctx))
			return (false);
		if (*current && (*current)->type == TOK_PIPE)
			return (create_pipeline(cmd, current, ctx));
	}
	return (true);
}

/**
 * @brief Parses tokens into a command structure
 *
 * @param ctx Context containing environment information
 * @param tokens The tokens array to parse
 * @return t_command* Parsed command structure
 */
t_command	*command_parse(t_ctx *ctx, t_token *tokens)
{
	t_command	*cmd;
	t_command	*first_cmd;
	t_token		*current;

	cmd = command_new();
	if (!cmd)
		return (NULL);
	first_cmd = cmd;
	current = tokens;
	if (!process_command_tokens(&current, cmd, ctx))
	{
		free_all_commands(first_cmd);
		return (NULL);
	}
	if (!create_pipeline(&cmd, &current, ctx))
	{
		free_all_commands(first_cmd);
		return (NULL);
	}
	return (first_cmd);
}
</file>

<file path="src/command/command_redirections.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_redirections.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 17:36:47 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 17:37:44 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Sets up input/output redirections for a command
 *
 * @param redirections List of redirections
 * @return int 0 on success, -1 on failure
 */
int	handle_redirections(t_redirection *redirections)
{
	t_redirection	*redir;
	int				fd;

	redir = redirections;
	while (redir)
	{
		if (redir->type == TOK_REDIR_FROM)
		{
			fd = open(redir->filename, O_RDONLY);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDIN_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_REDIR_TO)
		{
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDOUT_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_HERE_DOC_TO)
		{
			fd = open(redir->filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
			if (fd == -1)
				return (perror(redir->filename), -1);
			dup2(fd, STDOUT_FILENO);
			close(fd);
		}
		else if (redir->type == TOK_HERE_DOC_FROM)
		{
			// TODO: Implement heredoc with a pipe rather than a temp file
		}
		redir = redir->next;
	}
	return (0);
}
</file>

<file path="src/debug/debug_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 14:36:02 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:30:02 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "minishell.h"

/**
 * @brief Debug utility to display the current exit status
 *
 * @param ctx Context containing the shell state
 */
void	debug_exit_status(t_ctx *ctx)
{
	char	buffer[64];

	ft_strlcpy(buffer, "Exit status: ", sizeof(buffer));
	ft_strlcat(buffer, ft_itoa(ctx->exit_status), sizeof(buffer));
	debug_log(DEBUG_VERBOSE, "exit_status", buffer);
}

void	print_tokens_list(t_token *tokens)
{
	t_token	*current;
	int		token_count;

	current = tokens;
	token_count = 0;
	ft_printf(YELLOW "\n===== TOKEN LIST =====\n" RESET);
	while (current)
	{
		ft_printf(GREEN "Token %d: " RESET, token_count++);
		ft_printf("Type: " YELLOW);
		switch (current->type)
		{
		case TOK_WORD:
			ft_printf("WORD");
			break ;
		case TOK_REDIR_FROM:
			ft_printf("REDIR_FROM");
			break ;
		case TOK_REDIR_TO:
			ft_printf("REDIR_TO");
			break ;
		case TOK_HERE_DOC_FROM:
			ft_printf("HERE_DOC_FROM");
			break ;
		case TOK_HERE_DOC_TO:
			ft_printf("HERE_DOC_TO");
			break ;
		case TOK_PIPE:
			ft_printf("PIPE");
			break ;
		case TOK_ENV:
			ft_printf("ENV");
			break ;
		case TOK_AND:
			ft_printf("AND");
			break ;
		case TOK_OR:
			ft_printf("OR");
			break ;
		case TOK_NEW_LINE:
			ft_printf("NEW_LINE");
			break ;
		case TOK_EOF:
			ft_printf("EOF");
			break ;
		default:
			ft_printf("UNKNOWN");
			break ;
		}
		ft_printf(RESET);
		if (current->value)
			ft_printf(" | Value: " GREEN "%s" RESET, current->value);
		else
			ft_printf(" | Value: " GREEN "NULL" RESET);
		ft_printf("\n");
		current = current->next;
	}
	ft_printf(YELLOW "=====================\n\n" RESET);
}

void	print_redirection_type(t_token_type type)
{
	if (type == TOK_REDIR_FROM)
		ft_printf("< (REDIR_FROM)");
	else if (type == TOK_REDIR_TO)
		ft_printf("> (REDIR_TO)");
	else if (type == TOK_HERE_DOC_FROM)
		ft_printf("<< (HERE_DOC_FROM)");
	else if (type == TOK_HERE_DOC_TO)
		ft_printf(">> (HERE_DOC_TO)");
	else
		ft_printf("UNKNOWN");
}

void	print_redirections(t_redirection *redir)
{
	t_redirection	*current;
	int				redir_count;

	redir_count = 0;
	current = redir;
	if (!current)
	{
		ft_printf(YELLOW "  No redirections\n" RESET);
		return ;
	}
	ft_printf(YELLOW "  Redirections:\n" RESET);
	while (current)
	{
		ft_printf(GREEN "    Redirection %d: " RESET, redir_count++);
		ft_printf("Type: " YELLOW);
		print_redirection_type(current->type);
		ft_printf(RESET);
		ft_printf(" | Filename: " GREEN "%s" RESET, current->filename);
		ft_printf("\n");
		current = current->next;
	}
}

static char	*get_display_value(char *str)
{
	int		i;
	int		j;
	char	*result;
	int		in_squote;
	int		in_dquote;

	if (!str)
		return (ft_strdup("NULL"));
	result = malloc(ft_strlen(str) + 1);
	if (!result)
		return (ft_strdup("[malloc error]"));
	i = 0;
	j = 0;
	in_squote = 0;
	in_dquote = 0;
	while (str[i])
	{
		if (str[i] == '\'' && !in_dquote)
			in_squote = !in_squote;
		else if (str[i] == '"' && !in_squote)
			in_dquote = !in_dquote;
		else
			result[j++] = str[i];
		i++;
	}
	result[j] = '\0';
	return (result);
}

void	print_command_args(t_command *cmd)
{
	int		i;
	char	*display_value;

	i = 0;
	if (!cmd->args || cmd->arg_count == 0)
	{
		ft_printf(YELLOW "  No arguments\n" RESET);
		return ;
	}
	ft_printf(YELLOW "  Arguments:\n" RESET);
	while (i < cmd->arg_count)
	{
		display_value = get_display_value(cmd->args[i]);
		ft_printf(GREEN "    Arg %d: " RESET "%s\n", i, display_value);
		free(display_value);
		i++;
	}
}

void	print_operator_type(t_token_type op_type)
{
	if (op_type == TOK_PIPE)
		ft_printf(BLUE "  Piped to next command (|)\n" RESET);
	else if (op_type == TOK_OR)
		ft_printf(BLUE "  OR operator to next command (||)\n" RESET);
	else if (op_type == TOK_AND)
		ft_printf(BLUE "  AND operator to next command (&&)\n" RESET);
}

void	print_commands(t_command *cmd)
{
	t_command	*current;
	int			cmd_count;

	cmd_count = 0;
	current = cmd;
	ft_printf(YELLOW "\n===== COMMANDS =====\n" RESET);
	if (!current)
	{
		ft_printf(RED "No commands to display\n" RESET);
		ft_printf(YELLOW "===================\n\n" RESET);
		return ;
	}
	while (current)
	{
		ft_printf(GREEN "Command %d:\n" RESET, cmd_count++);
		print_command_args(current);
		print_redirections(current->redirection);
		if (current->next)
			print_operator_type(current->operator);
		current = current->next;
	}
	ft_printf(YELLOW "===================\n\n" RESET);
}

void	print_token_type(t_token_type type)
{
	if (type == TOK_WORD)
		ft_printf("WORD");
	else if (type == TOK_REDIR_FROM)
		ft_printf("REDIR_FROM");
	else if (type == TOK_REDIR_TO)
		ft_printf("REDIR_TO");
	else if (type == TOK_HERE_DOC_FROM)
		ft_printf("HERE_DOC_FROM");
	else if (type == TOK_HERE_DOC_TO)
		ft_printf("HERE_DOC_TO");
	else if (type == TOK_PIPE)
		ft_printf("PIPE");
	else if (type == TOK_ENV)
		ft_printf("ENV");
	else if (type == TOK_AND)
		ft_printf("AND");
	else if (type == TOK_OR)
		ft_printf("OR");
	else if (type == TOK_NEW_LINE)
		ft_printf("NEW_LINE");
	else if (type == TOK_EOF)
		ft_printf("EOF");
	else
		ft_printf("UNKNOWN");
}

void	print_single_token(t_token *token, int count)
{
	char	*display_value;

	ft_printf(GREEN "Token %d: " RESET, count);
	ft_printf("Type: " YELLOW);
	print_token_type(token->type);
	ft_printf(RESET);
	if (token->value)
	{
		display_value = get_display_value(token->value);
		ft_printf(" | Value: " GREEN "%s" RESET, display_value);
		free(display_value);
	}
	else
		ft_printf(" | Value: " GREEN "NULL" RESET);
	ft_printf("\n");
}

void	print_tokens(t_token *tokens)
{
	t_token	*current;
	int		token_count;

	current = tokens;
	token_count = 0;
	ft_printf(YELLOW "\n===== TOKEN LIST =====\n" RESET);
	if (!current)
	{
		ft_printf(RED "No tokens to display\n" RESET);
		ft_printf(YELLOW "=====================\n\n" RESET);
		return ;
	}
	while (current)
	{
		print_single_token(current, token_count);
		token_count++;
		current = current->next;
	}
	ft_printf(YELLOW "=====================\n\n" RESET);
}

void	cleanup(t_token *tokens)
{
	if (tokens)
		free_all_token(tokens);
	clear_history();
	rl_clear_history();
	rl_free_line_state();
	rl_cleanup_after_signal();
}

void	handle_signal(int sig)
{
	(void)sig;
	ft_printf("\nExiting...\n");
	cleanup(NULL);
	exit(0);
}

// #include <signal.h>

// int	main(int argc, char **argv, char **envp)
// {
// 	char		*input;
// 	t_token		*tokens;
// 	t_command	*commands;
// 	t_ctx		*ctx;
// 	int			status;

// 	(void)argc;
// 	(void)argv;
// 	ctx = init_ctx(argc, argv, envp);
// 	if (!ctx)
// 		return (1);
// 	status = 0;
// 	while (status == 0)
// 	{
// 		input = readline(YELLOW "minishell$ " RESET);
// 		if (!input)
// 			break ;
// 		if (input[0] != '\0')
// 			add_history(input);
// 		if (ft_strncmp(input, "exit", ft_strlen(input)) == 0)
// 		{
// 			free(input);
// 			break ;
// 		}
// 		tokens = tokenize(NULL, input);
// 		if (tokens)
// 		{
// 			print_tokens(tokens);
// 			commands = parse_token(tokens, ctx);
// 			if (commands)
// 			{
// 				print_commands(commands);
// 				free_all_commands(commands);
// 			}
// 			free_all_token(tokens);
// 		}
// 		free(input);
// 	}
// 	free_env_list(ctx->env_list);
// 	free(ctx);
// 	return (0);
// }

// /**
//  * @brief Processes a single line from input file
//  *
//  * @param ctx Shell context
//  * @param line Line to process
//  * @return 0 to continue, 1 to exit
//  */
// static int process_line(t_ctx *ctx, char *line)
// {
// 	t_token		*tokens;
// 	t_command	*commands;
//
// 	if (!line || line[0] == '\0')
// 		return (0);
// 	if (line[0] == '#')
// 		return (0);
// 	if (ft_strncmp(line, "exit", ft_strlen("exit")) == 0
// 		&& (line[4] == ' ' || line[4] == '\0' || line[4] == '\n'))
// 		return (1);
// 	ft_printf(BLUE"[Command]"RESET" %s\n", line);
// 	tokens = tokenize(line);
// 	if (!tokens)
// 	{
// 		ft_printf(RED"Error: Failed to tokenize input\n"RESET);
// 		return (0);
// 	}
// 	print_tokens(tokens);
// 	commands = parse_token(tokens, ctx);
// 	if (!commands)
// 	{
// 		ft_printf(RED"Error: Failed to parse tokens\n"RESET);
// 		free_all_token(tokens);
// 		return (0);
// 	}
// 	print_commands(commands);
// 	free_all_commands(commands);
// 	free_all_token(tokens);
// 	return (0);
// }
//
// /**
//  * @brief Processes commands from a file
//  *
//  * @param ctx Shell context
//  * @param filename Name of file to read commands from
//  * @return Exit status
//  */
// static int process_file(t_ctx *ctx, char *filename)
// {
// 	int		fd;
// 	char	*line;
// 	int		exit_status;
//
// 	fd = open(filename, O_RDONLY);
// 	if (fd < 0)
// 	{
// 		ft_printf(RED"Error: Could not open file %s\n"RESET, filename);
// 		return (1);
// 	}
// 	ft_printf(GREEN"Processing commands from file: %s\n"RESET, filename);
// 	exit_status = 0;
// 	while (1)
// 	{
// 		line = get_next_line(fd);
// 		if (!line)
// 			break ;
// 		if (line[ft_strlen(line) - 1] == '\n')
// 			line[ft_strlen(line) - 1] = '\0';
//
// 		if (process_line(ctx, line))
// 		{
// 			exit_status = ctx->exit_status;
// 			free(line);
// 			break ;
// 		}
// 		free(line);
// 	}
// 	close(fd);
// 	return (exit_status);
// }
//
// int	main(int argc, char **argv, char **envp)
// {
// 	t_ctx	*ctx;
// 	int		exit_status;
//
// 	ctx = init_ctx(envp);
// 	if (!ctx)
// 		return (1);
// 	ctx->interactive = 0;
// 	if (argc < 2)
// 	{
// 		ft_printf(RED"Usage: %s <filename>\n"RESET, argv[0]);
// 		free_ctx(ctx);
// 		return (1);
// 	}
// 	exit_status = process_file(ctx, argv[1]);
// 	free_ctx(ctx);
// 	return (exit_status);
// }
</file>

<file path="src/debug/debug.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:20:06 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 13:45:03 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"

int					g_debug_level = DEBUG_NONE;

/**
 * @brief Initialize debug system with specified verbosity level
 *
 * @param level Debug verbosity level
 */
void	debug_init(int level)
{
	g_debug_level = level;
}

/**
 * @brief Log a debug message if current level is high enough
 *
 * @param level Required debug level to show this message
 * @param module Module name for the log
 * @param msg Log message to display
 */
void	debug_log(int level, const char *module, const char *msg)
{
	if (g_debug_level >= level)
	{
		ft_putstr_fd((char *)CYAN, STDERR_FILENO);
		ft_putstr_fd((char *)"[DEBUG] ", STDERR_FILENO);
		if (module)
		{
			ft_putstr_fd((char *)module, STDERR_FILENO);
			ft_putstr_fd((char *)": ", STDERR_FILENO);
		}
		ft_putstr_fd((char *)msg, STDERR_FILENO);
		ft_putstr_fd((char *)RESET, STDERR_FILENO);
		ft_putstr_fd((char *)"\n", STDERR_FILENO);
	}
}

/**
 * @brief Get string representation of token type
 *
 * @param type Token type to convert
 * @return String representing the token type
 */
static const char	*get_token_type_str(t_token_type type)
{
	if (type == TOK_WORD)
		return ("WORD");
	if (type == TOK_REDIR_FROM)
		return ("REDIR_FROM");
	if (type == TOK_REDIR_TO)
		return ("REDIR_TO");
	if (type == TOK_HERE_DOC_FROM)
		return ("HERE_DOC_FROM");
	if (type == TOK_HERE_DOC_TO)
		return ("HERE_DOC_TO");
	if (type == TOK_PIPE)
		return ("PIPE");
	if (type == TOK_ENV)
		return ("ENV");
	if (type == TOK_AND)
		return ("AND");
	if (type == TOK_OR)
		return ("OR");
	if (type == TOK_NEW_LINE)
		return ("NEW_LINE");
	if (type == TOK_EOF)
		return ("EOF");
	return ("UNKNOWN");
}

/**
 * @brief Print a single token for debugging
 *
 * @param level Required debug level to show this
 * @param token Token to print
 */
void	debug_print_token(int level, t_token *token)
{
	char	buffer[512];

	if (g_debug_level < level || !token)
		return ;
	ft_strlcpy(buffer, "Token: Type=", sizeof(buffer));
	ft_strlcat(buffer, get_token_type_str(token->type), sizeof(buffer));
	ft_strlcat(buffer, ", Value=", sizeof(buffer));
	if (token->value)
		ft_strlcat(buffer, token->value, sizeof(buffer));
	else
		ft_strlcat(buffer, "NULL", sizeof(buffer));
	debug_log(level, "lexer", buffer);
}

/**
 * @brief Print all tokens in a list for debugging
 *
 * @param level Required debug level to show this
 * @param tokens Tokens list to print
 */
void	debug_print_tokens(int level, t_token *tokens)
{
	t_token	*current;
	int		count;

	if (g_debug_level < level)
		return ;
	debug_log(level, "lexer", "Token list:");
	current = tokens;
	count = 0;
	while (current)
	{
		debug_print_token(level, current);
		current = current->next;
		count++;
	}
}

/**
 * @brief Print a command structure for debugging
 *
 * @param level Required debug level to show this
 * @param cmd Command to print
 */
void	debug_print_command(int level, t_command *cmd)
{
	char			buffer[512];
	t_redirection	*redir;
	char			*count_str;
	int				i;

	if (g_debug_level < level || !cmd)
		return ;
	debug_log(level, "parser", "Command:");
	if (cmd->args && cmd->args[0])
	{
		ft_strlcpy(buffer, "Command name: ", sizeof(buffer));
		ft_strlcat(buffer, cmd->args[0], sizeof(buffer));
		debug_log(level, "parser", buffer);
	}
	i = 1;
	while (cmd->args && i <= cmd->arg_count)
	{
		ft_strlcpy(buffer, "Arg[", sizeof(buffer));
		count_str = ft_itoa(i - 1);
		ft_strlcat(buffer, count_str, sizeof(buffer));
		free(count_str);
		ft_strlcat(buffer, "]: ", sizeof(buffer));
		ft_strlcat(buffer, cmd->args[i], sizeof(buffer));
		debug_log(level, "parser", buffer);
		i++;
	}
	redir = cmd->redirection;
	while (redir)
	{
		ft_strlcpy(buffer, "Redirection: type=", sizeof(buffer));
		ft_strlcat(buffer, get_token_type_str(redir->type), sizeof(buffer));
		ft_strlcat(buffer, ", file=", sizeof(buffer));
		ft_strlcat(buffer, redir->filename, sizeof(buffer));
		debug_log(level, "parser", buffer);
		redir = redir->next;
	}
}

/**
 * @brief Print all commands in a pipeline for debugging
 *
 * @param level Required debug level to show this
 * @param cmd First command in the pipeline
 */
void	debug_print_commands(int level, t_command *cmd)
{
	t_command	*current;
	int			count;
	char		buffer[64];
	char		*count_str;

	if (g_debug_level < level)
		return ;
	debug_log(level, "parser", "Command pipeline:");
	current = cmd;
	count = 0;
	while (current)
	{
		count_str = ft_itoa(count);
		ft_strlcpy(buffer, "Command #", sizeof(buffer));
		ft_strlcat(buffer, count_str, sizeof(buffer));
		free(count_str);
		debug_log(level, "parser", buffer);
		debug_print_command(level, current);
		if (current->next)
		{
			ft_strlcpy(buffer, "Operator: ", sizeof(buffer));
			ft_strlcat(buffer, get_token_type_str(current->operator),
				sizeof(buffer));
			debug_log(level, "parser", buffer);
		}
		current = current->next;
		count++;
	}
}
</file>

<file path="src/env/env_find_bin.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_find_bin.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:40:56 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:46:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "error.h"

/**
 * @brief Creates default path directories when PATH env var is not set
 *
 * @return char** Array of default path directories or NULL if error
 */
static char	**create_default_path_dirs(void)
{
	char	**path_dirs;

	path_dirs = malloc(sizeof(char *) * 5);
	if (!path_dirs)
		return (NULL);
	path_dirs[0] = ft_strdup("/bin");
	path_dirs[1] = ft_strdup("/usr/bin");
	path_dirs[2] = ft_strdup("/usr/local/bin");
	path_dirs[3] = ft_strdup("/sbin");
	path_dirs[4] = NULL;
	return (path_dirs);
}

/**
 * @brief Normalizes path directories by removing trailing slashes
 *
 * @param path_dirs Array of path directories to normalize
 */
static void	normalize_path_dirs(char **path_dirs)
{
	int	i;
	int	len;

	i = 0;
	while (path_dirs[i])
	{
		len = (int)ft_strlen(path_dirs[i]);
		if (len > 0 && path_dirs[i][len - 1] == '/')
			path_dirs[i][len - 1] = '\0';
		i++;
	}
}

/**
 * @brief Gets PATH directories from environment
 *
 * @param ctx Context
 * @return char** Array of path directories or NULL if error
 */
static char	**env_get_path_dirs(t_ctx *ctx)
{
	char	*path_var;
	char	**path_dirs;

	path_var = env_find(ctx, (char *)"PATH=");
	if (!path_var)
		return (create_default_path_dirs());
	path_dirs = ft_split(path_var, ':');
	free(path_var);
	if (!path_dirs)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	normalize_path_dirs(path_dirs);
	return (path_dirs);
}

/**
 * @brief Tries to find a binary in PATH
 *
 * @param ctx Context
 * @param bin The binary to search for
 * @return char* A full path to the binary if found and executable, or NULL
 */
char	*env_find_bin(t_ctx *ctx, char *bin)
{
	char	**path_dirs;
	char	**og_path_dirs;
	char	*path;

	if (!bin)
		return (NULL);
	path_dirs = env_get_path_dirs(ctx);
	if (!path_dirs)
		return (NULL);
	og_path_dirs = path_dirs;
	while (*path_dirs)
	{
		path = bin_find_path(*path_dirs, bin);
		if (path)
		{
			free_2d_array((void **)og_path_dirs);
			return (path);
		}
		path_dirs++;
	}
	free_2d_array((void **)og_path_dirs);
	return (NULL);
}
</file>

<file path="src/env/env_find.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_find.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:13:07 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 14:40:05 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Search for a variable in the environment and return a duplicate
 *
 * @param app The app structure
 * @param var The variable to search for
 * @return char* Environment variable content
 *
 * @note The searched variable *must* end with a '='
 */
char	*env_find(t_ctx *ctx, char *var)
{
	size_t	i;
	size_t	len;
	char	*env_var;

	if (!ctx->envp)
		return (NULL);
	i = 0;
	len = ft_strlen(var);
	while (ctx->envp[i])
	{
		if (ft_strncmp(ctx->envp[i], var, len) == 0)
		{
			env_var = ft_strdup(ctx->envp[i] + len);
			return (env_var);
		}
		i++;
	}
	return (NULL);
}
</file>

<file path="src/env/env_quotes.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_quotes.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/18 17:55:13 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 18:21:27 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Checks if a character is a single quote
 *
 * @param c Character to check
 * @return 1 if single quote, 0 otherwise
 */
static int	is_single_quote(char c)
{
	return (c == '\'');
}

/**
 * @brief Checks if a character is a double quote
 *
 * @param c Character to check
 * @return 1 if double quote, 0 otherwise
 */
static int	is_double_quote(char c)
{
	return (c == '"');
}

/**
 * @brief Updates quote state based on current character
 *
 * @param c Current character
 * @param in_squote Pointer to single quote state
 * @param in_dquote Pointer to double quote state
 */
static void	update_quote_state(char c, int *in_squote, int *in_dquote)
{
	if (is_single_quote(c) && !(*in_dquote))
		*in_squote = !(*in_squote);
	else if (is_double_quote(c) && !(*in_squote))
		*in_dquote = !(*in_dquote);
}

/**
 * @brief Handles expanding variables during string processing
 *
 * @param ctx Context containing environment information
 * @param str Input string
 * @param i Position in string (will be updated)
 * @param result Current result string
 * @return Updated result string
 */
static char	*handle_var_expansion(t_ctx *ctx, char *str, int *i, char *result)
{
	char	*var_value;
	char	*temp_result;
	int		in_squote;

	in_squote = 0;
	var_value = expand_variable(ctx, str, i, in_squote);
	if (!var_value)
		return (result);
	temp_result = join_and_free(result, var_value);
	free(var_value);
	return (temp_result);
}

/**
 * @brief Processes a string, handling quotes and variable expansion
 *
 * @param ctx Context containing variable information
 * @param str String to process
 * @param result Current result string
 * @return Updated result string
 */
static char	*process_string(t_ctx *ctx, char *str, char *result)
{
	int		i;
	int		start;
	int		in_squote;
	int		in_dquote;
	char	*temp_result;

	i = 0;
	start = 0;
	in_squote = 0;
	in_dquote = 0;
	while (str[i])
	{
		update_quote_state(str[i], &in_squote, &in_dquote);
		if (str[i] == '$' && !in_squote)
		{
			temp_result = append_part(result, str, start, i);
			if (!temp_result)
				return (result);
			result = temp_result;
			result = handle_var_expansion(ctx, str, &i, result);
			start = i;
			continue ;
		}
		i++;
	}
	temp_result = append_part(result, str, start, i);
	return (temp_result);
}

/**
 * @brief Handles quotes and variables in a string
 *
 * @param ctx Context containing variable information
 * @param str Input string to process
 * @return Newly allocated string with processed content
 */
char	*handle_quotes_and_vars(t_ctx *ctx, char *str)
{
	char	*result;
	char	*processed;

	if (!str)
		return (ft_strdup(""));
	result = ft_strdup("");
	if (!result)
		return (NULL);
	processed = process_string(ctx, str, result);
	return (processed);
}
</file>

<file path="src/env/env.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 12:30:04 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 18:22:14 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Process a part of a string and append it to the result
 *
 * @param result Current result string
 * @param str Input string
 * @param start Start position
 * @param end End position
 * @return Updated result string
 */
char	*append_part(char *result, char *str, int start, int end)
{
	char	*part;
	char	*new_result;

	if (end <= start)
		return (result);
	part = ft_substr(str, start, end - start);
	if (!part)
		return (result);
	new_result = join_and_free(result, part);
	free(part);
	return (new_result);
}

/**
 * @brief Gets the value of an environment variable
 *
 * @param env_list Environment variable list
 * @param key Key to look for
 * @return Value of the variable or NULL if not found
 */
char	*get_env_value(t_env *env_list, char *key)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (ft_strncmp(current->key, key, ft_strlen(key)) == 0
			&& ft_strlen(current->key) == ft_strlen(key))
			return (current->value);
		current = current->next;
	}
	return (NULL);
}

/**
 * @brief Expands a variable name to its value
 *
 * @param ctx Context containing the current shell state
 * @param var_name Name of the variable to expand
 * @return char* Expanded value as a new string (caller must free)
 */
char	*expand_var(t_ctx *ctx, char *var_name)
{
	char	*value;

	if (!var_name)
		return (ft_strdup(""));
	if (ft_strncmp(var_name, "?", ft_strlen(var_name)) == 0)
		return (ft_itoa(ctx->exit_status));
	value = get_env_value(ctx->env_list, var_name);
	if (value)
		return (ft_strdup(value));
	return (ft_strdup(""));
}

/**
 * @brief Gets a variable name from a string
 *
 * @param str String containing the variable
 * @param pos Position in the string (will be updated)
 * @return Newly allocated string with variable name or NULL
 */
static char	*get_var_name(char *str, int *pos)
{
	char	*name;
	int		len;
	int		i;

	i = *pos;
	if (str[i] == '?')
	{
		(*pos)++;
		return (ft_strdup("?"));
	}
	len = 0;
	while (ft_isalnum(str[i + len]) || str[i + len] == '_')
		len++;
	if (len == 0)
		return (NULL);
	name = malloc(len + 1);
	if (!name)
		return (NULL);
	ft_strlcpy(name, str + i, len + 1);
	*pos += len;
	return (name);
}

/**
 * @brief Handles variable expansion based on quote context
 *
 * @param ctx Shell context
 * @param str Input string
 * @param i Current position (will be updated)
 * @param in_squote Whether in single quotes
 * @return Expanded variable or dollar sign
 */
char	*expand_variable(t_ctx *ctx, char *str, int *i, int in_squote)
{
	char	*var_name;
	char	*var_value;

	(*i)++;
	if (in_squote)
		return (ft_strdup("$"));
	if (str[*i] == '?')
	{
		(*i)++;
		return (ft_itoa(ctx->exit_status));
	}
	var_name = get_var_name(str, i);
	var_value = expand_var(ctx, var_name);
	free(var_name);
	return (var_value);
}
</file>

<file path="src/error/ctx_error_exit.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ctx_error_exit.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 17:07:35 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:45:59 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Frees context, displays an error and quits with the corresponding
 * exit code
 *
 * @param ctx context
 * @param err error code
 */
void	ctx_error_exit(t_ctx *ctx, t_error_type err)
{
	if (ctx)
		ctx_clear(ctx);
	errno = ctx_error(err);
	exit(errno);
}
</file>

<file path="src/error/error_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:35:19 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 10:35:22 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"

/**
 * @brief Displays an error and gets an exit code
 *
 * @param err Error type
 * @return int Exit code
 */
int	ctx_error(t_error_type err)
{
	return (ctx_error_level(err, ERROR));
}

/**
 * @brief Gets the error table object
 *
 * @return t_error_info* The error table map
 */
t_error_info	*get_error_table(void)
{
	t_error_info	*error_table;

	error_table = malloc(32 * sizeof(t_error_info));
	error_table[ERR_NONE] = (t_error_info){0, "Success", false};
	error_table[ERR_CMD_NOT_FOUND] = (t_error_info){127, "Command not found",
		false};
	error_table[ERR_NO_PERMISSION] = (t_error_info){EACCES, "Permission denied",
		true};
	error_table[ERR_IO_ERROR] = (t_error_info){EIO, "Input/output error", true};
	error_table[ERR_UNIMPLEMENTED] = (t_error_info){ENOSYS,
		"Not implemented yet", true};
	error_table[ERR_ALLOC] = (t_error_info){ENOMEM,
		"Allocation failed. Your RAM might be full", true};
	error_table[ERR_PIPE] = (t_error_info){EPIPE, "Pipe error", false};
	error_table[ERR_CHILD] = (t_error_info){ECHILD, "Fork error", false};
	error_table[ERR_NO_SUCH_FILE] = (t_error_info){ENOENT,
		"No such file or directory", false};
	return (error_table);
}

/**
 * @brief Displays an error and gets an exit code
 *
 * @param err Error type
 * @param level Error level
 * @return int Exit code
 */
int	ctx_error_level(t_error_type err, t_error_level level)
{
	t_error_info	*error_table;
	t_error_info	*info;
	char			*msg;
	int				code;

	error_table = get_error_table();
	info = &error_table[err];
	msg = (char *)info->message;
	if (info->use_perror)
		msg = strerror(info->code);
	error_print(level, "minishell", msg);
	code = info->code;
	free(error_table);
	return (code);
}

/**
 * @brief Print a system error message using errno
 *
 * @param level Error severity level
 * @param module Name of the module where error occurred
 */
static void	error_print_sys(t_error_level level, const char *module)
{
	error_print(level, module, strerror(errno));
}

/**
 * @brief Exit the program with an error message
 *
 * @param ctx Context to clean up
 * @param err Error type to report
 * @param module Name of the module where error occurred
 */
void	error_exit(t_ctx *ctx, t_error_type err, const char *module)
{
	t_error_info	*info;
	t_error_info	*error_table;
	int				code;

	if (ctx)
		ctx_clear(ctx);
	error_table = get_error_table();
	info = &error_table[err];
	if (info->use_perror)
		error_print_sys(FATAL, module);
	else
		error_print(FATAL, module, info->message);
	code = info->code;
	free(error_table);
	exit(code);
}
</file>

<file path="src/error/error.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:20:00 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:19:26 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"

/**
 * @brief Get color code based on error level
 *
 * @param level Error severity level
 * @return Corresponding color code string
 */
static const char	*get_level_color(t_error_level level)
{
	if (level == INFO)
		return (BLUE);
	if (level == WARNING)
		return (YELLOW);
	if (level == ERROR)
		return (RED);
	if (level == FATAL)
		return (MAGENTA);
	return (RESET);
}

/**
 * @brief Get text representation of error level
 *
 * @param level Error severity level
 * @return Text description of the level
 */
static const char	*get_level_text(t_error_level level)
{
	if (level == INFO)
		return ("INFO");
	if (level == WARNING)
		return ("WARNING");
	if (level == ERROR)
		return ("ERROR");
	if (level == FATAL)
		return ("FATAL");
	return ("UNKNOWN");
}

/**
 * @brief Print an error message with appropriate formatting
 *
 * @param level Error severity level
 * @param module Name of the module where error occurred
 * @param msg Error message to display
 */
void	error_print(t_error_level level, const char *module, const char *msg)
{
	const char	*color;
	const char	*level_text;

	color = get_level_color(level);
	level_text = get_level_text(level);
	ft_putstr_fd((char *)color, STDERR_FILENO);
	ft_putstr_fd((char *)"[", STDERR_FILENO);
	ft_putstr_fd((char *)level_text, STDERR_FILENO);
	ft_putstr_fd((char *)"] ", STDERR_FILENO);
	if (module)
	{
		ft_putstr_fd((char *)module, STDERR_FILENO);
		ft_putstr_fd((char *)": ", STDERR_FILENO);
	}
	ft_putstr_fd((char *)msg, STDERR_FILENO);
	ft_putstr_fd((char *)RESET, STDERR_FILENO);
	ft_putstr_fd((char *)"\n", STDERR_FILENO);
}

/**
 * @brief Get numeric error code from error type
 *
 * @param err Error type
 * @return int Integer error code
 */
int	error_code(t_error_type err)
{
	t_error_info	*info;
	t_error_info	*error_table;
	int				code;

	error_table = get_error_table();
	info = &error_table[err];
	code = info->code;
	free(error_table);
	return (code);
}
</file>

<file path="src/exec/exec_cmdas_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:33:08 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:52:37 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Executes a single command in the pipeline
 *
 * @param ctx Context with environment
 * @param cmd Current command to execute
 * @param input_fd Input file descriptor
 * @param output_fd Output file descriptor
 * @return pid_t Process ID of the child
 */
pid_t	exec_piped_command(t_ctx *ctx, t_command *cmd, int input_fd,
		int output_fd)
{
	pid_t	pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork");
		return (-1);
	}
	if (pid == 0)
		setup_child_process(ctx, cmd, input_fd, output_fd);
	return (pid);
}

/**
 * @brief Creates a pipe for the next command
 *
 * @param pipe_fds Array to store pipe file descriptors
 * @return int 0 on success, -1 on error
 */
int	setup_pipe(int pipe_fds[2])
{
	if (pipe(pipe_fds) == -1)
	{
		perror("pipe");
		return (-1);
	}
	return (0);
}

/**
 * @brief Waits for all child processes and reports status
 *
 * @param pids Array of process IDs
 * @param count Number of processes
 * @return int Exit status of the last command
 */
int	wait_for_pids(pid_t *pids, int count)
{
	int	i;
	int	status;
	int	last_status;

	i = 0;
	last_status = 0;
	while (i < count)
	{
		if (pids[i] > 0)
			waitpid(pids[i], &status, 0);
		if (i == count - 1 && pids[i] > 0)
		{
			if (WIFEXITED(status))
				last_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
				last_status = 128 + WTERMSIG(status);
		}
		i++;
	}
	return (last_status);
}
</file>

<file path="src/exec/exec_cmdas_utils2.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas_utils2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:52:23 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 15:55:36 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Counts the number of commands in a pipeline
 *
 * @param cmd The first command in the pipeline
 * @return int The number of commands
 */
int	count_commands(t_command *cmd)
{
	int			count;
	t_command	*current;

	count = 0;
	current = cmd;
	while (current)
	{
		count++;
		current = current->next;
	}
	return (count);
}

/**
 * @brief Handles command execution after redirection setup
 *
 * @param ctx Context with environment
 * @param cmd Command to execute
 * @return void
 */
static void	execute_command(t_ctx *ctx, t_command *cmd)
{
	char	*bin_path;

	if (builtins_try(ctx, cmd))
		exit(EXIT_SUCCESS);
	if (!cmd->args || !cmd->args[0])
		exit(EXIT_FAILURE);
	bin_path = bin_find(ctx, cmd->args[0]);
	if (!bin_path)
	{
		ft_printf("Command not found: %s\n", cmd->args[0]);
		exit(EXIT_FAILURE);
	}
	free(cmd->args[0]);
	cmd->args[0] = bin_path;
	if (execve(cmd->args[0], cmd->args, ctx->envp) == -1)
	{
		perror("execve");
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Sets up the child process for command execution
 *
 * @param ctx Context with environment
 * @param cmd Command to execute
 * @param input_fd Input file descriptor
 * @param output_fd Output file descriptor
 */
void	setup_child_process(t_ctx *ctx, t_command *cmd, int input_fd,
		int output_fd)
{
	reset_signals();
	if (input_fd != STDIN_FILENO)
	{
		dup2(input_fd, STDIN_FILENO);
		close(input_fd);
	}
	if (output_fd != STDOUT_FILENO)
	{
		dup2(output_fd, STDOUT_FILENO);
		close(output_fd);
	}
	if (handle_redirections(cmd->redirection) != 0)
		exit(EXIT_FAILURE);
	execute_command(ctx, cmd);
}
</file>

<file path="src/exec/exec_cmdas.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmdas.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 16:37:25 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:36:25 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "memory.h"
#include "minishell.h"

/**
 * @brief Handles pipe setup for commands
 *
 * @param pipe_fds Pipe file descriptors
 * @param i Index of current command
 * @param cmd_count Total command count
 * @return int 0 on success, -1 on error
 */
static int	handle_pipe_setup(int pipe_fds[2], int i, int cmd_count)
{
	if (i < cmd_count - 1)
	{
		if (setup_pipe(pipe_fds) == -1)
			return (-1);
	}
	else
		pipe_fds[1] = STDOUT_FILENO;
	return (0);
}

/**
 * @brief Handles descriptor management after fork
 *
 * @param prev_pipe Previous pipe's read end
 * @param pipe_fds Current pipe file descriptors
 * @param i Current command index
 * @param cmd_count Total command count
 * @return int Updated previous pipe file descriptor
 */
static int	handle_descriptors(int prev_pipe, int pipe_fds[2], int i,
		int cmd_count)
{
	if (prev_pipe != STDIN_FILENO)
		close(prev_pipe);
	if (pipe_fds[1] != STDOUT_FILENO)
		close(pipe_fds[1]);
	if (i < cmd_count - 1)
		return (pipe_fds[0]);
	return (prev_pipe);
}

/**
 * @brief Execute one command in the pipeline process
 *
 * @param ctx Context information
 * @param data Structure with pipe information
 * @return int Updated previous pipe file descriptor
 */
static int	process_pipeline_cmd(t_ctx *ctx, t_pipe_data *data)
{
	if (handle_pipe_setup(data->pipe_fds, data->i, data->cmd_count) == -1)
		return (-1);
	setup_parent_signals();
	data->pids[data->i] = exec_piped_command(ctx, data->current,
			data->prev_pipe, data->pipe_fds[1]);
	return (handle_descriptors(data->prev_pipe, data->pipe_fds, data->i,
			data->cmd_count));
}

/**
 * @brief Initialize pipe data structure
 *
 * @param data Pipe data structure to initialize
 * @param ctx Context with command info
 * @return t_bool TRUE on success, FALSE on failure
 */
static t_bool	init_pipe_data(t_pipe_data *data, t_ctx *ctx)
{
	data->current = ctx->cmd;
	data->cmd_count = count_commands(data->current);
	data->i = 0;
	data->prev_pipe = STDIN_FILENO;
	data->pids = malloc(sizeof(pid_t) * (size_t)data->cmd_count);
	if (!data->pids)
		return (false);
	return (true);
}

/**
 * @brief Execute the commands in a pipeline
 *
 * @param ctx Context
 * @return Exit status of the last command
 */
int	exec_cmdas(t_ctx *ctx)
{
	t_pipe_data	data;
	int			exit_status;
	int			i;
	char		*a;
	char		error_buf[64];

	debug_log(DEBUG_INFO, "pipeline", "Starting pipeline execution");
	if (!init_pipe_data(&data, ctx))
	{
		error_print(ERROR, "pipeline", "Failed to initialize pipeline data");
		ctx->exit_status = error_code(ERR_ALLOC);
		return (ctx->exit_status);
	}
	setup_parent_signals();
	i = 0;
	while (i < data.cmd_count)
	{
		debug_log(DEBUG_INFO, "pipeline", "Processing command in pipeline");
		data.prev_pipe = process_pipeline_cmd(ctx, &data);
		if (data.prev_pipe == -1)
		{
			free(data.pids);
			error_print(ERROR, "pipeline", "Pipe processing failed");
			ctx->exit_status = error_code(ERR_PIPE);
			return (ctx->exit_status);
		}
		data.current = data.current->next;
		data.i++;
		i++;
	}
	debug_log(DEBUG_INFO, "pipeline", "Waiting for child processes");
	exit_status = wait_for_pids(data.pids, data.cmd_count);
	ft_strlcpy(error_buf, "Pipeline exit status: ", sizeof(error_buf));
	a = ft_itoa(exit_status);
	ft_strlcat(error_buf, a, sizeof(error_buf));
	free(a);
	debug_log(DEBUG_INFO, "pipeline", error_buf);
	setup_signals();
	free(data.pids);
	return (exit_status);
}
</file>

<file path="src/free/ctx_exit.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ctx_exit.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 17:15:04 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:30:49 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Clears the context and exits the app gracefully
 *
 * @param ctx context
 */
void	ctx_exit(t_ctx *ctx)
{
	ctx_clear(ctx);
	exit(EXIT_SUCCESS);
}
</file>

<file path="src/free/free_2d_array.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_2d_array.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 16:38:09 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/08 15:07:04 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees a NULL-terminated pointer of pointers
 *
 * @param ptrs The pointer of pointers to free
 */
void	free_2d_array(void **ptrs)
{
	int	i;

	if (!ptrs)
		return ;
	i = 0;
	while (ptrs[i])
	{
		free(ptrs[i]);
		i++;
	}
	free(ptrs);
}
</file>

<file path="src/free/free_command.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_command.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:49:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 14:04:10 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees memory allocated for a redirection structure
 *
 * This function releases all memory associated with a redirection structure
 * including the filename.
 *
 * @param redirection Redirection structure to free
 */
static void	free_redirection(t_redirection *redirection)
{
	if (!redirection)
		return ;
	if (redirection->filename)
		free(redirection->filename);
	free(redirection);
}

/**
 * @brief Frees memory allocated for all redirections in a linked list
 *
 * This function traverses a linked list of redirections and frees each one.
 *
 * @param redirection First redirection in the linked list
 */
static void	free_all_redirections(t_redirection *redirection)
{
	t_redirection	*current;
	t_redirection	*next;

	current = redirection;
	while (current)
	{
		next = current->next;
		free_redirection(current);
		current = next;
	}
}

/**
 * @brief Frees memory allocated for command arguments
 *
 * This function releases all memory associated with the args array.
 *
 * @param args Array of argument strings
 * @param arg_count Number of arguments in the array
 */
static void	free_command_args(char **args, int arg_count)
{
	int	i;

	if (!args)
		return ;
	i = 0;
	while (i <= arg_count)
	{
		if (args[i])
			free(args[i]);
		i++;
	}
	free(args);
}

/**
 * @brief Frees memory allocated for a command structure
 *
 * This function releases all memory associated with a command structure
 * including arguments and redirections.
 *
 * @param cmd Command structure to free
 */
void	free_command(t_command *cmd)
{
	if (!cmd)
		return ;
	free_command_args(cmd->args, cmd->arg_count);
	free_all_redirections(cmd->redirection);
	free(cmd);
}

/**
 * @brief Frees memory allocated for all commands in a pipeline
 *
 * This function traverses a linked list of commands and frees each one.
 *
 * @param cmd First command in the linked list
 */
void	free_all_commands(t_command *cmd)
{
	t_command	*current;
	t_command	*next;

	current = cmd;
	while (current)
	{
		next = current->next;
		free_command(current);
		current = next;
	}
}
</file>

<file path="src/free/free_ctx.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_ctx.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 18:24:28 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 14:03:34 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Clears the context and frees all allocated resources
 *
 * @param ctx context
 */
void	ctx_clear(t_ctx *ctx)
{
	if (!ctx)
		return ;
	if (ctx->tokens)
		free_all_token(ctx->tokens);
	ctx->tokens = NULL;
	if (ctx->cmd)
		free_command(ctx->cmd);
	ctx->cmd = NULL;
	clear_history();
	rl_free_line_state();
	rl_cleanup_after_signal();
	if (ctx->fd_file_in != -1)
		close(ctx->fd_file_in);
	if (ctx->fd_file_out != -1)
		close(ctx->fd_file_out);
	if (ctx->env_list)
		free_env_list(ctx->env_list);
	free(ctx);
}
</file>

<file path="src/free/free_env.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:42:24 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:35:12 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Frees environment variable list
 *
 * @param env_list List to free
 */
void	free_env_list(t_env *env_list)
{
	t_env	*current;
	t_env	*next;

	current = env_list;
	while (current)
	{
		next = current->next;
		free(current->key);
		if (current->value)
			free(current->value);
		free(current);
		current = next;
	}
}

/**
 * @brief Parses an environment variable string
 *
 * @param env_str Environment variable string (KEY=VALUE)
 * @param env_list Pointer to the environment list
 * @return 1 if successful, 0 on error
 */
int	parse_env_var(char *env_str, t_env **env_list)
{
	char	*equals_pos;
	char	*key;
	char	*value;
	int		key_len;
	int		result;

	equals_pos = ft_strchr(env_str, '=');
	if (!equals_pos)
		return (add_env_var(env_list, env_str, NULL));
	key_len = (int)(equals_pos - env_str);
	key = (char *)malloc((size_t)(key_len + 1));
	if (!key)
		return (0);
	ft_strlcpy(key, env_str, (size_t)(key_len + 1));
	value = equals_pos + 1;
	result = add_env_var(env_list, key, value);
	free(key);
	return (result);
}
</file>

<file path="src/free/pipes_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 10:24:52 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/13 12:09:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Closes all pipe file descriptors if they are valid
 *
 * @param pipes Array of pipe file descriptors
 */
void	close_all_pipes(int pipes[2][2])
{
	if (pipes[0][0] >= 0)
		close(pipes[0][0]);
	if (pipes[0][1] >= 0)
		close(pipes[0][1]);
	if (pipes[1][0] >= 0)
		close(pipes[1][0]);
	if (pipes[1][1] >= 0)
		close(pipes[1][1]);
}

/**
 * @brief Closes only the previous pipe file descriptors
 *
 * @param pipes Array of pipe file descriptors
 * @param cmd_index Current command index
 */
void	close_previous_pipe(int pipes[2][2], int cmd_index)
{
	if (cmd_index > 0)
	{
		if (pipes[0][0] >= 0)
			close(pipes[0][0]);
		if (pipes[0][1] >= 0)
			close(pipes[0][1]);
	}
}
</file>

<file path="src/init/init_ctx.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_ctx.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 10:56:03 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:38:37 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Initializes the environment in the context
 *
 * @param ctx Context
 * @param envp Environment
 */
static void	init_ctx_envp(t_ctx *ctx, char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		if (!parse_env_var(envp[i], &ctx->env_list))
		{
			ctx_clear(ctx);
			return ;
		}
		i++;
	}
}

/**
 * @brief Initializes the context
 *
 * @param argc Arguments count
 * @param argv Arguments
 * @param envp Environment variables
 * @return t_ctx* Context
 */
t_ctx	*init_ctx(int argc, char **argv, char **envp)
{
	t_ctx	*ctx;

	ctx = malloc(sizeof(t_ctx));
	if (!ctx)
		return (NULL);
	ctx->env_list = NULL;
	init_ctx_envp(ctx, envp);
	ctx->exit_requested = false;
	ctx->exit_status = 0;
	ctx->interactive = 1;
	ctx->tokens = NULL;
	ctx->cmd = NULL;
	ctx->argc = argc;
	ctx->argv = argv;
	ctx->envp = envp;
	ctx->fd_file_in = -1;
	ctx->fd_file_out = -1;
	return (ctx);
}

/**
 * @brief Creates a new environment variable node
 *
 * @param key Key of the environment variable
 * @param value Value of the environment variable
 * @return New environment variable node or NULL if allocation fails
 */
static t_env	*create_env_node(char *key, char *value)
{
	t_env	*new_node;

	new_node = (t_env *)malloc(sizeof(t_env));
	if (!new_node)
		return (NULL);
	new_node->key = ft_strdup(key);
	if (!new_node->key)
	{
		free(new_node);
		return (NULL);
	}
	if (value)
	{
		new_node->value = ft_strdup(value);
		if (!new_node->value)
		{
			free(new_node->key);
			free(new_node);
			return (NULL);
		}
	}
	else
		new_node->value = NULL;
	new_node->next = NULL;
	return (new_node);
}

/**
 * @brief Adds an environment variable to the list
 *
 * @param env_list Pointer to the list head
 * @param key Key of the environment variable
 * @param value Value of the environment variable
 * @return 1 if successful, 0 on error
 */
int	add_env_var(t_env **env_list, char *key, char *value)
{
	t_env	*new_node;
	t_env	*current;

	new_node = create_env_node(key, value);
	if (!new_node)
		return (0);
	if (!*env_list)
	{
		*env_list = new_node;
		return (1);
	}
	current = *env_list;
	while (current->next)
		current = current->next;
	current->next = new_node;
	return (1);
}
</file>

<file path="src/init/init_parse.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_parse.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:14:26 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:36:12 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Creates and initializes a new token
 *
 * @param type Token type enumeration
 * @param value String value of the token
 * @return New token pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_token	*create_token(t_token_type type, char *value)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->type = type;
	token->next = NULL;
	token->value = value;
	return (token);
}

/**
 * @brief Creates and initializes a new command
 *
 * @return New command pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_command	*create_command(void)
{
	t_command	*cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
		return (NULL);
	cmd->redirection = NULL;
	cmd->next = NULL;
	cmd->args = NULL;
	cmd->arg_count = 0;
	return (cmd);
}

/**
 * @brief Creates and initializes a new command
 *
 * @param type
 * @param filename
 * @return New command pointer or NULL if allocation fails
 * @note Caller must free the returned token
 */
t_redirection	*create_redirection(t_token_type type, char *filename)
{
	t_redirection	*redirection;

	redirection = malloc(sizeof(t_redirection));
	if (!redirection)
		return (NULL);
	redirection->type = type;
	redirection->next = NULL;
	redirection->filename = ft_strdup(filename);
	if (!redirection->filename)
	{
		free(redirection);
		return (NULL);
	}
	return (redirection);
}

void	init_parse_context(t_parse *parse, t_token *token)
{
	parse->token = token;
	parse->current = token;
}
</file>

<file path="src/lexer/lexer_read_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_read_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 10:43:47 by maximart          #+#    #+#             */
/*   Updated: 2025/03/19 10:43:50 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Joins two strings and frees the first one
 *
 * @param s1 First string (will be freed)
 * @param s2 Second string
 * @return Newly allocated joined string or NULL on error
 */
char	*join_and_free(char *s1, char *s2)
{
	char	*result;

	if (!s1)
		return (ft_strdup(s2));
	result = ft_strjoin(s1, s2);
	free(s1);
	return (result);
}

/**
 * @brief Handle dollar sign during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @return Updated result buffer with position at dollar sign
 */
char	*handle_dollar_sign(char *result)
{
	if (!result)
		result = ft_strdup("");
	return (result);
}

/**
 * @brief Handle word part during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @return Updated result buffer or NULL on error
 */
char	*handle_word_part(t_lexer *lexer, char *result)
{
	char	*part;

	part = read_word_lexer(lexer);
	result = join_and_free(result, part);
	free(part);
	return (result);
}

/**
 * @brief Handle quoted part during complex word reading
 *
 * @param lexer Pointer to lexer structure
 * @param result Current result buffer
 * @param quote_char Quote character (single or double)
 * @return Updated result buffer or NULL on error
 */
char	*handle_quoted_part(t_lexer *lexer, char *result, char quote_char)
{
	char	*part;

	part = read_quoted_string_lexer(lexer, quote_char);
	if (!part)
	{
		free(result);
		return (NULL);
	}
	result = join_and_free(result, part);
	free(part);
	return (result);
}
</file>

<file path="src/lexer/lexer_read.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_read.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:27:07 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:51:57 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Extract a word from lexer input
 *
 * @param lexer Pointer to lexer structure
 * @return Newly allocated string containing the word or NULL on error
 * @note Caller must free the returned string
 */
char	*read_word_lexer(t_lexer *lexer)
{
	int		start;
	int		length;
	char	*word;

	start = lexer->position;
	while (get_lexer(lexer) != '\0' && get_lexer(lexer) != ' '
		&& get_lexer(lexer) != '\t' && get_lexer(lexer) != '\n'
		&& get_lexer(lexer) != '|' && get_lexer(lexer) != '<'
		&& get_lexer(lexer) != '>' && get_lexer(lexer) != '&'
		&& get_lexer(lexer) != '"' && get_lexer(lexer) != '$'
		&& get_lexer(lexer) != '\'')
		advance_lexer(lexer);
	length = lexer->position - start;
	if (length == 0)
		return (ft_strdup(""));
	word = malloc((unsigned long)length + 1);
	if (!word)
		return (NULL);
	ft_strlcpy(word, lexer->input + start, (size_t)length + 1);
	word[length] = '\0';
	return (word);
}

char	*read_quoted_string_lexer(t_lexer *lexer, char quote_char)
{
	int		start;
	int		end;
	char	*content;

	start = lexer->position + 1;
	advance_lexer(lexer);
	while (get_lexer(lexer) != '\0' && get_lexer(lexer) != quote_char)
		advance_lexer(lexer);
	if (get_lexer(lexer) == '\0')
	{
		ft_printf(RED "error:\nUnclosed quote\n" RESET);
		return (NULL);
	}
	end = lexer->position;
	advance_lexer(lexer);
	content = malloc((unsigned long)(end - start + 1));
	if (!content)
		return (NULL);
	ft_strlcpy(content, lexer->input + start, (size_t)(end - start + 1));
	content[end - start] = '\0';
	return (content);
}

static int	peek_lexer(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	return (current != '\0' && current != ' ' && current != '\t'
		&& current != '\n' && current != '|' && current != '<'
		&& current != '>' && current != '&');
}

/**
 * @brief Reads a complex word that might contain various elements
 *
 * @param lexer Pointer to lexer structure
 * @return Newly allocated string containing the word or NULL on error
 */
char	*read_complex_word(t_lexer *lexer)
{
	char	*result;
	char	quote_char;

	result = NULL;
	while (peek_lexer(lexer))
	{
		if (get_lexer(lexer) == '"' || get_lexer(lexer) == '\'')
		{
			quote_char = get_lexer(lexer);
			result = handle_quoted_part(lexer, result, quote_char);
			if (!result)
				return (NULL);
		}
		else if (get_lexer(lexer) == '$')
		{
			result = handle_dollar_sign(result);
			break ;
		}
		else
			result = handle_word_part(lexer, result);
	}
	if (!result)
		return (ft_strdup(""));
	return (result);
}
</file>

<file path="src/lexer/lexer_token_is.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token_is.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 13:58:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/12 18:00:00 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Checks if a token is a redirection token
 *
 * @param tok Token type to check
 * @return t_bool true if token is a redirection, false otherwise
 */
t_bool	token_is_redirection(t_token_type type)
{
	return (type == TOK_REDIR_FROM || type == TOK_REDIR_TO
		|| type == TOK_HERE_DOC_FROM || type == TOK_HERE_DOC_TO);
}
</file>

<file path="src/lexer/lexer_token_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 15:53:31 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:39:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token	*handle_basics_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '\0')
		return (create_token(TOK_EOF, NULL));
	if (current == '\n')
	{
		advance_lexer(lexer);
		return (create_token(TOK_NEW_LINE, ft_strdup("\n")));
	}
	return (NULL);
}

t_token	*handle_pipe_and_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '|')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '|')
		{
			advance_lexer(lexer);
			return (create_token(TOK_OR, ft_strdup("||")));
		}
		return (create_token(TOK_PIPE, ft_strdup("|")));
	}
	if (current == '&')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '&')
		{
			advance_lexer(lexer);
			return (create_token(TOK_AND, ft_strdup("&&")));
		}
		ft_printf(RED "Error:\nUnexpected '&'\n" RESET);
		return (create_token(TOK_EOF, NULL));
	}
	return (NULL);
}

t_token	*handle_redir_from_and_to_token(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	if (current == '<')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '<')
		{
			advance_lexer(lexer);
			return (create_token(TOK_HERE_DOC_FROM, ft_strdup("<<")));
		}
		return (create_token(TOK_REDIR_FROM, ft_strdup("<")));
	}
	else if (current == '>')
	{
		advance_lexer(lexer);
		if (get_lexer(lexer) == '>')
		{
			advance_lexer(lexer);
			return (create_token(TOK_HERE_DOC_TO, ft_strdup(">>")));
		}
		return (create_token(TOK_REDIR_TO, ft_strdup(">")));
	}
	return (NULL);
}

/**
 * Checks if the current lexer character is a lone '$' symbol.
 *
 * @param lexer Pointer to the lexer structure
 * @return 1 if lone '$', 0 otherwise
 */
static int	is_lone_dollar(t_lexer *lexer)
{
	char	current;

	current = get_lexer(lexer);
	return (current == ' ' || current == '\t' || current == '\0'
		|| current == '<' || current == '>' || current == '|'
		|| current == '"' || current == '\'' || current == '&'
		|| current == '\n');
}

t_token	*handle_env_token(t_lexer *lexer)
{
	char	*word;
	char	current;

	current = get_lexer(lexer);
	if (current == '$')
	{
		advance_lexer(lexer);
		if (is_lone_dollar(lexer))
			return (create_token(TOK_WORD, ft_strdup("$")));
		word = read_word_lexer(lexer);
		if (!word || word[0] == '\0')
		{
			if (word)
				free(word);
			return (create_token(TOK_WORD, ft_strdup(" $")));
		}
		return (create_token(TOK_ENV, word));
	}
	return (NULL);
}
</file>

<file path="src/lexer/lexer_token.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_token.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:31:33 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:40:13 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_token	*handle_word_token(t_lexer *lexer)
{
	char	*word;

	word = read_complex_word(lexer);
	if (!word)
		return (NULL);
	if (word[0] == '\0' && get_lexer(lexer) == '$')
	{
		free(word);
		return (handle_env_token(lexer));
	}
	return (create_token(TOK_WORD, word));
}

/**
 * @brief Extracts the next token from the lexer
 *
 * @param lexer Pointer to lexer structure
 * @return Next token or NULL on error
 * @note Caller must free the returned token
 */
t_token	*next_token_lexer(t_lexer *lexer)
{
	t_token	*token;

	skip_whitespace_lexer(lexer);
	token = handle_basics_token(lexer);
	if (token)
		return (token);
	token = handle_pipe_and_token(lexer);
	if (token)
		return (token);
	token = handle_redir_from_and_to_token(lexer);
	if (token)
		return (token);
	if (get_lexer(lexer) == '$')
	{
		token = handle_env_token(lexer);
		if (token)
			return (token);
	}
	token = handle_word_token(lexer);
	if (token)
		return (token);
	return (NULL);
}

static void	free_token(t_token *token)
{
	if (token)
	{
		free(token->value);
		free(token);
	}
}

/**
 * @brief Frees all tokens in a linked list
 *
 * This function releases the memory allocated for all tokens
 * in a linked list, starting from the given token.
 *
 * @param token First token in the list
 */
void	free_all_token(t_token *token)
{
	t_token	*current;
	t_token	*next;

	current = token;
	while (current)
	{
		next = current->next;
		free_token(current);
		current = next;
	}
}
</file>

<file path="src/lexer/lexer_tokenize.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_tokenize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/14 15:28:06 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/18 12:29:21 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "memory.h"
#include "minishell.h"

/**
 * @brief Adds a token to the linked list, updating head/current pointers
 */
static void	add_token_to_list(t_token **head, t_token **current, t_token *token)
{
	if (!*head)
	{
		*head = token;
		*current = token;
	}
	else
	{
		(*current)->next = token;
		*current = token;
	}
}

/**
 * @brief Builds the token list from lexer input
 */
static int	build_token_list(t_lexer *lexer, t_token **head)
{
	t_token	*token;
	t_token	*current;

	current = NULL;
	while (1)
	{
		token = next_token_lexer(lexer);
		if (!token)
		{
			free_all_token(*head);
			return (0);
		}
		add_token_to_list(head, &current, token);
		if (token->type == TOK_EOF)
			break ;
	}
	return (1);
}

/**
 * @brief Tokenizes input string into a linked list of tokens
 *
 * @param ctx Context for error handling
 * @param input The input string to tokenize
 * @return Linked list of tokens or NULL on error
 */
t_token	*tokenize(t_ctx *ctx, char *input)
{
	t_lexer	*lexer;
	t_token	*head;

	head = NULL;
	debug_log(DEBUG_INFO, "lexer", "Tokenizing input");
	if (!input)
	{
		error_print(ERROR, "lexer", "NULL input string");
		return (NULL);
	}
	lexer = safe_malloc(ctx, sizeof(t_lexer), "lexer");
	lexer->input = input;
	lexer->position = 0;
	lexer->length = (int)ft_strlen(input);
	if (!build_token_list(lexer, &head))
	{
		error_print(ERROR, "lexer", "Failed to build token list");
		free(lexer);
		return (NULL);
	}
	free(lexer);
	debug_log(DEBUG_INFO, "lexer", "Tokenization complete");
	return (head);
}
</file>

<file path="src/lexer/lexer_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maximart <maximart@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 19:17:06 by maximart          #+#    #+#             */
/*   Updated: 2025/03/05 19:17:08 by maximart         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Return current character at lexer position
 *
 * @param lexer Pointer to lexer structure
 * @return Current character or '\0' if at end of input
 */
char	get_lexer(t_lexer *lexer)
{
	if (lexer->position >= lexer->length)
		return ('\0');
	return (lexer->input[lexer->position]);
}

/**
 * @brief Advance lexer position by one character
 *
 * @param lexer Pointer to lexer structure
 */
void	advance_lexer(t_lexer *lexer)
{
	if (lexer->position < lexer->length)
		lexer->position++;
}

/**
 * @brief Skip whitespaces characters in lexer input
 *
 * @param lexer Pointer to lexer structure
 */
void	skip_whitespace_lexer(t_lexer *lexer)
{
	while (get_lexer(lexer) == ' ' || get_lexer(lexer) == '\t')
		advance_lexer(lexer);
}
</file>

<file path="src/memory/memory.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:34:04 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:34:09 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "memory.h"

/**
 * @brief Safely allocates memory with error handling
 *
 * @param ctx Shell context for error handling
 * @param size Size to allocate
 * @param module Module name for error reporting
 * @return Allocated memory or exits on failure
 */
void	*safe_malloc(t_ctx *ctx, size_t size, const char *module)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		error_print(FATAL, module, "Memory allocation failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (ptr);
}

/**
 * @brief Safely duplicates a string with error handling
 *
 * @param ctx Shell context for error handling
 * @param str String to duplicate
 * @param module Module name for error reporting
 * @return Duplicated string or exits on failure
 */
char	*safe_strdup(t_ctx *ctx, const char *str, const char *module)
{
	char	*dup;

	if (!str)
		return (NULL);
	dup = ft_strdup(str);
	if (!dup)
	{
		error_print(FATAL, module, "String duplication failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (dup);
}

/**
 * @brief Safely joins two strings with error handling
 *
 * @param ctx Shell context for error handling
 * @param s1 First string
 * @param s2 Second string
 * @param module Module name for error reporting
 * @return Joined string or exits on failure
 */
char	*safe_strjoin(t_ctx *ctx, const char *s1, const char *s2,
		const char *module)
{
	char	*result;

	result = ft_strjoin(s1, s2);
	if (!result)
	{
		error_print(FATAL, module, "String join failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (result);
}

/**
 * @brief Safely allocates and zeros memory with error handling
 *
 * @param ctx Shell context for error handling
 * @param nmemb Number of elements
 * @param size Size of each element
 * @param module Module name for error reporting
 * @return Allocated memory or exits on failure
 */
void	*safe_calloc(t_ctx *ctx, size_t nmemb, size_t size, const char *module)
{
	void	*ptr;

	ptr = ft_calloc(nmemb, size);
	if (!ptr)
	{
		error_print(FATAL, module, "Memory allocation failed");
		error_exit(ctx, ERR_ALLOC, module);
	}
	return (ptr);
}
</file>

<file path="src/parser/parser_command.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_command.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:37:01 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:47:01 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Adds an argument to a command
 *
 * This function adds a new argument to a command's argument list,
 * allocating memory as needed.
 *
 * @param cmd Command to add the argument to
 * @param value Value of the argument to add
 * @return 1 on success, 0 on failure
 */
int	add_argument(t_command *cmd, char *value)
{
	char	**new_args;
	int		i;

	if (!cmd || !value)
		return (0);
	new_args = malloc(sizeof(char *) * (size_t)(cmd->arg_count + 2));
	if (!new_args)
		return (0);
	i = -1;
	while (++i < cmd->arg_count)
		new_args[i] = cmd->args[i];
	new_args[i] = ft_strdup(value);
	if (!new_args[i])
	{
		free(new_args);
		return (0);
	}
	new_args[i + 1] = NULL;
	if (cmd->args)
		free(cmd->args);
	cmd->args = new_args;
	cmd->arg_count++;
	return (1);
}

/**
 * @brief Adds a redirection to a command
 *
 * This function adds a new redirection to a command's redirection list.
 *
 * @param cmd Command to add the redirection to
 * @param redirection Redirection to add
 */
void	add_redirection(t_command *cmd, t_redirection *redirection)
{
	t_redirection	*current;

	if (!cmd->redirection)
	{
		cmd->redirection = redirection;
		return ;
	}
	current = cmd->redirection;
	while (current->next)
		current = current->next;
	current->next = current;
}

/**
 * @brief Parses a redirection with environment variable expansion
 *
 * @param parse Parser context
 * @param cmd Command structure
 * @param ctx Shell context
 * @return 1 if successful, 0 on error
 */
int	parse_redirection(t_parse *parse, t_command *cmd, t_ctx *ctx)
{
	t_token_type	type;
	t_redirection	*redirection;
	char			*expanded;

	type = parse->current->type;
	advance_parse(parse);
	if (!parse->current || parse->current->type != TOK_WORD)
	{
		ft_printf(RED "Error: Expected filename after redirection\n" RESET);
		return (0);
	}
	if (type == TOK_HERE_DOC_FROM)
		redirection = create_redirection(type, parse->current->value);
	else
	{
		expanded = handle_quotes_and_vars(ctx, parse->current->value);
		redirection = create_redirection(type, expanded);
		free(expanded);
	}
	if (!redirection)
		return (0);
	add_redirection(cmd, redirection);
	advance_parse(parse);
	return (1);
}

/**
 * @brief Parses a command with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_command(t_parse *parse, t_ctx *ctx)
{
	t_command	*cmd;
	char		*expanded;

	cmd = create_command();
	if (!cmd)
		return (NULL);
	while (parse->current && parse->current->type != TOK_PIPE
		&& parse->current->type != TOK_AND && parse->current->type != TOK_OR
		&& parse->current->type != TOK_EOF)
	{
		if (parse->current->type == TOK_WORD)
		{
			expanded = handle_quotes_and_vars(ctx, parse->current->value);
			if (!add_argument(cmd, expanded))
			{
				free(expanded);
				free_command(cmd);
				return (NULL);
			}
			free(expanded);
			advance_parse(parse);
		}
		else if (parse->current->type == TOK_ENV)
		{
			expanded = expand_var(ctx, parse->current->value);
			if (!add_argument(cmd, expanded))
			{
				free(expanded);
				free_command(cmd);
				return (NULL);
			}
			free(expanded);
			advance_parse(parse);
		}
		else if (parse->current->type == TOK_REDIR_FROM
			|| parse->current->type == TOK_REDIR_TO
			|| parse->current->type == TOK_HERE_DOC_FROM
			|| parse->current->type == TOK_HERE_DOC_TO)
		{
			if (!parse_redirection(parse, cmd, ctx))
			{
				free_command(cmd);
				return (NULL);
			}
		}
		else
			advance_parse(parse);
	}
	return (cmd);
}
</file>

<file path="src/parser/parser_pipeline.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_pipeline.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:39:38 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:48:16 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Parses a pipeline with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_pipeline(t_ctx *ctx, t_parse *parse)
{
	t_command	*first_cmd;
	t_command	*current_cmd;

	first_cmd = parse_command(parse, ctx);
	if (!first_cmd)
		return (NULL);
	current_cmd = first_cmd;
	while (parse->current && (parse->current->type == TOK_PIPE
			|| parse->current->type == TOK_OR
			|| parse->current->type == TOK_AND))
	{
		current_cmd->operator = parse->current->type;
		advance_parse(parse);
		current_cmd->next = parse_command(parse, ctx);
		if (!current_cmd->next)
		{
			free_all_commands(first_cmd);
			return (NULL);
		}
		current_cmd = current_cmd->next;
	}
	return (first_cmd);
}

static void	connect_commands(t_command *left_cmd, t_command *right_cmd,
	t_token_type op_type)
{
	t_command	*last_cmd;

	last_cmd = left_cmd;
	while (last_cmd->next)
		last_cmd = last_cmd->next;
	last_cmd->next = right_cmd;
	last_cmd->operator = op_type;
}

/**
 * @brief Parses a command sequence with environment variable expansion
 *
 * @param parse Parser context
 * @param ctx Shell context
 * @return Command structure or NULL on error
 */
t_command	*parse_command_sequence(t_ctx *ctx, t_parse *parse)
{
	t_command		*left_cmd;
	t_command		*right_cmd;
	t_token_type	op_type;

	left_cmd = parse_pipeline(ctx, parse);
	if (!left_cmd)
		return (NULL);
	if (parse->current->type != TOK_AND && parse->current->type != TOK_OR)
		return (left_cmd);
	op_type = parse->current->type;
	advance_parse(parse);
	right_cmd = parse_command_sequence(ctx, parse);
	if (!right_cmd)
	{
		free_all_commands(left_cmd);
		return (NULL);
	}
	connect_commands(left_cmd, right_cmd, op_type);
	return (left_cmd);
}
</file>

<file path="src/parser/parser_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 14:35:40 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 11:42:31 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	advance_parse(t_parse *parse)
{
	if (parse->current && parse->current->type != TOK_EOF)
		parse->current = parse->current->next;
}

int	check_parse(t_parse *parse, t_token_type type)
{
	return (parse->current && parse->current->type == type);
}

int	check_token_type(t_parse *parse, t_token_type type)
{
	return (parse->current && parse->current->type == type);
}

char	*get_token_value(t_parse *parse)
{
	if (!parse->current)
		return (NULL);
	return (parse->current->value);
}

int	consume_parse(t_parse *parse, t_token_type type)
{
	if (check_parse(parse, type))
	{
		advance_parse(parse);
		return (1);
	}
	return (0);
}
</file>

<file path="src/path/bin_find_path.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bin_find_path.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:59:39 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:46:35 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Checks if a file exists and is executable
 *
 * @param path Path to the file to check
 * @return int 1 if file exists and is executable, 0 otherwise
 */
static int	is_executable(const char *path)
{
	if (access(path, F_OK) == 0)
	{
		if (access(path, X_OK) == 0)
			return (1);
	}
	return (0);
}

/**
 * @brief Checks if a binary is found in a directory and is executable
 *
 * @param dir The path to search in
 * @param bin The binary to search for
 * @return char* Full path to binary if found and executable, NULL otherwise
 */
char	*bin_find_path(const char *dir, char *bin)
{
	char	*tmp;
	char	*full_path;

	if (!dir || !bin)
		return (NULL);
	tmp = ft_strjoin(dir, "/");
	if (!tmp)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	full_path = ft_strjoin(tmp, bin);
	free(tmp);
	if (!full_path)
	{
		ctx_error(ERR_ALLOC);
		return (NULL);
	}
	if (is_executable(full_path))
		return (full_path);
	free(full_path);
	return (NULL);
}
</file>

<file path="src/path/bin_find.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bin_find.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 14:56:48 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 18:15:25 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"

/**
 * @brief Checks if a string is a path and not just a command
 *
 * @param str The string to check
 * @return t_bool true if the string is a path, false if just a command
 */
static t_bool	is_path(const char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (false);
	if (str[0] == '~' && (str[1] == '/' || str[1] == '\0'))
		return (true);
	if (str[0] == '/')
		return (true);
	while (str[i])
	{
		if (str[i] == '/' || (str[i] == '.' && (str[i + 1] == '/' || str[i
						+ 1] == '\0' || (str[i + 1] == '.' && (str[i + 2] == '/'
							|| str[i + 2] == '\0')))))
			return (true);
		i++;
	}
	return (false);
}

/**
 * @brief Tries to execute file directly if it's a path
 *
 * @param bin Binary path to check
 * @return char* strdup of bin if executable, NULL otherwise
 */
static char	*try_direct_path(char *bin, t_path_error *error_state)
{
	if (access(bin, F_OK) != 0)
	{
		*error_state = PATH_ERR_NOT_FOUND;
		return (NULL);
	}
	if (access(bin, X_OK) != 0)
	{
		*error_state = PATH_ERR_NO_PERMISSION;
		return (NULL);
	}
	return (ft_strdup(bin));
}

/**
 * @brief Resolves a relative path to an absolute path
 *
 * @param bin Path to resolve
 * @return char* Absolute path or NULL on error
 */
static char	*resolve_relative_path(char *bin)
{
	char	*cwd;
	char	*absolute_path;
	char	*tmp;

	if (bin[0] == '/')
		return (ft_strdup(bin));
	cwd = getcwd(NULL, 0);
	if (!cwd)
		return (NULL);
	tmp = ft_strjoin(cwd, "/");
	free(cwd);
	if (!tmp)
		return (NULL);
	absolute_path = ft_strjoin(tmp, bin);
	free(tmp);
	return (absolute_path);
}

/**
 * @brief Finds a binary in the PATH or current directory
 *
 * @param ctx Context
 * @param bin The binary to search for
 * @return char* Path to binary if found, NULL otherwise
 */
char	*bin_find(t_ctx *ctx, char *bin)
{
	char			*path;
	t_path_error	error_state;

	error_state = PATH_ERR_NONE;
	if (!bin)
		return (NULL);
	if (is_path(bin))
	{
		path = try_direct_path(bin, &error_state);
		if (path)
			return (path);
		if (bin[0] != '/' && error_state == PATH_ERR_NONE)
		{
			path = resolve_relative_path(bin);
			if (path && access(path, X_OK) == 0)
				return (path);
			if (path && access(path, F_OK) == 0)
				error_state = PATH_ERR_NO_PERMISSION;
			else
				error_state = PATH_ERR_NOT_FOUND;
			free(path);
		}
		path = bin_find_path(".", bin);
		if (path)
			return (path);
		if (error_state == PATH_ERR_NOT_FOUND)
			error_print(ERROR, bin, "No such file or directory");
		else if (error_state == PATH_ERR_NO_PERMISSION)
			error_print(ERROR, bin, "Permission denied");
		return (NULL);
	}
	else
	{
		path = env_find_bin(ctx, bin);
		if (!path)
			error_print(ERROR, bin, "Command not found");
	}
	return (path);
}
</file>

<file path="src/redir/heredoc.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:30:10 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:57:55 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Replaces a substring in a string with another substring
 *
 * @param str Original string
 * @param start Start index of substring to replace
 * @param end End index of substring to replace
 * @param replacement Replacement string
 * @return Newly allocated string with replacement
 */
static char	*replace_substring(char *str, int start, int end, char *replacement)
{
	char	*prefix;
	char	*suffix;
	char	*temp1;
	char	*temp2;

	prefix = ft_substr(str, 0, start);
	if (!prefix)
		return (NULL);
	suffix = ft_strdup(str + end);
	if (!suffix)
	{
		free(prefix);
		return (NULL);
	}
	temp1 = ft_strjoin(prefix, replacement);
	free(prefix);
	if (!temp1)
	{
		free(suffix);
		return (NULL);
	}
	temp2 = ft_strjoin(temp1, suffix);
	free(temp1);
	free(suffix);
	free(str);
	return (temp2);
}

/**
 * @brief Expands environment variables in a line
 *
 * @param ctx Context containing environment info
 * @param line Line to expand variables in
 * @return Newly allocated string with expanded variables
 */
static char	*expand_variables(t_ctx *ctx, char *line)
{
	char	*result;
	char	*var_start;
	char	*var_name;
	char	*var_value;
	int		i;
	int		j;

	if (!line)
		return (NULL);
	result = ft_strdup(line);
	if (!result)
		return (NULL);
	var_start = ft_strchr(result, '$');
	while (var_start)
	{
		i = var_start - result;
		j = i + 1;
		while (result[j] && (ft_isalnum(result[j]) || result[j] == '_'))
			j++;
		var_name = ft_substr(result, i + 1, j - i - 1);
		var_name = ft_strjoin(var_name, "=");
		if (!var_name)
		{
			free(result);
			return (NULL);
		}
		var_value = env_find(ctx, var_name);
		free(var_name);
		if (!var_value)
			var_value = ft_strdup("");
		if (!var_value)
		{
			free(result);
			return (NULL);
		}
		result = replace_substring(result, i, j, var_value);
		free(var_value);
		if (!result)
			return (NULL);
		var_start = ft_strchr(result, '$');
	}
	return (result);
}

/**
 * @brief Processes a line read for heredoc
 *
 * @param line Line read from input
 * @param ctx Context containing environment information
 * @param pipe_fd File descriptor to write to
 * @return 0 on success, -1 on error
 */
static int	process_heredoc_line(char *line, t_ctx *ctx, int pipe_fd)
{
	char	*expanded_line;

	if (!line)
		return (-1);
	expanded_line = expand_variables(ctx, line);
	free(line);
	if (!expanded_line)
		return (-1);
	write(pipe_fd, expanded_line, ft_strlen(expanded_line));
	write(pipe_fd, "\n", 1);
	free(expanded_line);
	return (0);
}

/**
 * @brief Reads content for heredoc until delimiter is found
 *
 * @param pipe_fd File descriptor to write heredoc content to
 * @param delimiter String marking end of heredoc
 * @param ctx Context containing environment information
 * @return 0 on success, -1 on error, 1 on EOF
 */
static int	read_heredoc_content(int pipe_fd, char *delimiter, t_ctx *ctx)
{
	char	*line;
	int		delimiter_len;

	delimiter_len = ft_strlen(delimiter);
	while (1)
	{
		line = readline("> ");
		if (!line)
		{
			error_print(WARNING, "heredoc",
				"here-document delimited by end-of-file");
			return (1);
		}
		if (ft_strncmp(line, delimiter, delimiter_len + 1) == 0)
		{
			free(line);
			break ;
		}
		if (process_heredoc_line(line, ctx, pipe_fd) == -1)
			return (-1);
	}
	return (0);
}

/**
 * @brief Creates a here-document for input redirection
 *
 * @param ctx Context containing environment information
 * @param delimiter String marking end of heredoc
 * @return File descriptor to read from, or -1 on error
 */
static int	create_heredoc(t_ctx *ctx, char *delimiter)
{
	int	pipe_fds[2];
	int	result;

	if (pipe(pipe_fds) == -1)
	{
		perror("pipe");
		return (-1);
	}
	result = read_heredoc_content(pipe_fds[1], delimiter, ctx);
	close(pipe_fds[1]);
	if (result == -1)
	{
		close(pipe_fds[0]);
		return (-1);
	}
	return (pipe_fds[0]);
}

/**
 * @brief Handles here_doc redirections for a command
 *
 * @param ctx Context containing environment information
 * @param cmd Command containing redirections
 * @return 0 on success, non-zero on error
 */
int	setup_heredocs(t_ctx *ctx, t_command *cmd)
{
	t_redirection	*redir;
	int				heredoc_fd;
	int				dup_result;

	redir = cmd->redirection;
	while (redir)
	{
		if (redir->type == TOK_HERE_DOC_FROM)
		{
			heredoc_fd = create_heredoc(ctx, redir->filename);
			if (heredoc_fd == -1)
				return (-1);
			dup_result = dup2(heredoc_fd, STDIN_FILENO);
			close(heredoc_fd);
			if (dup_result == -1)
			{
				perror("dup2");
				return (-1);
			}
		}
		redir = redir->next;
	}
	return (0);
}
</file>

<file path="src/redir/redirections.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:45:10 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:23:08 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"

/**
 * @brief Opens a file based on redirection type
 *
 * @param type Redirection type (input, output, append)
 * @param filename Name of the file to open
 * @return File descriptor or -1 on error
 */
static int	open_redirect_file(t_token_type type, char *filename)
{
	int	fd;

	fd = -1;
	if (type == TOK_REDIR_FROM)
		fd = open(filename, O_RDONLY);
	else if (type == TOK_REDIR_TO)
		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (type == TOK_HERE_DOC_TO)
		fd = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd == -1)
		perror(filename);
	return (fd);
}

/**
 * @brief Redirects standard file descriptors
 *
 * @param fd File descriptor to redirect to/from
 * @param type Type of redirection
 * @return 0 on success, -1 on error
 */
static int	redirect_std_fd(int fd, t_token_type type)
{
	int	target_fd;
	int	dup_result;

	if (fd < 0)
		return (-1);
	if (type == TOK_REDIR_FROM)
		target_fd = STDIN_FILENO;
	else
		target_fd = STDOUT_FILENO;
	dup_result = dup2(fd, target_fd);
	close(fd);
	if (dup_result == -1)
	{
		perror("dup2");
		return (-1);
	}
	return (0);
}

/**
 * @brief Processes a single redirection
 *
 * @param redir Redirection to process
 * @return 0 on success, -1 on error
 */
static int	process_redirection(t_redirection *redir)
{
	int	fd;
	int	redirect_result;

	if (redir->type == TOK_HERE_DOC_FROM)
		return (0);
	fd = open_redirect_file(redir->type, redir->filename);
	if (fd == -1)
		return (-1);
	redirect_result = redirect_std_fd(fd, redir->type);
	return (redirect_result);
}

/**
 * @brief Sets up all redirections for a command
 *
 * @param ctx Context for error handling
 * @param redirections List of redirections
 * @return 0 on success, -1 on error
 */
int	setup_redirections(t_redirection *redirections)
{
	t_redirection	*redir;
	int				result;
	char			error_msg[256];

	redir = redirections;
	if (!redir)
	{
		debug_log(DEBUG_INFO, "redir", "No redirections to process");
		return (0);
	}
	debug_log(DEBUG_INFO, "redir", "Setting up redirections");
	while (redir)
	{
		debug_log(DEBUG_VERBOSE, "redir", "Processing redirection");
		result = process_redirection(redir);
		if (result != 0)
		{
			ft_strlcpy(error_msg, "Failed to set up redirection for: ", 256);
			ft_strlcat(error_msg, redir->filename, 256);
			error_print(ERROR, "redir", error_msg);
			return (result);
		}
		redir = redir->next;
	}
	debug_log(DEBUG_INFO, "redir", "All redirections processed successfully");
	return (0);
}
</file>

<file path="src/signals/signals.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 17:58:55 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/14 14:42:43 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Global variable to track if we're in a child process
 * This will help us determine how to handle signals.
 */
static volatile sig_atomic_t	g_in_child = 0;

/**
 * @brief Signal handler for interactive mode (shell prompt)
 * Handles SIGINT (CTRL+C) by printing a newline and redisplaying the prompt
 *
 * @param sig Signal number
 */
static void	sig_interactive_handler(int sig)
{
	if (sig == SIGINT)
	{
		write(STDOUT_FILENO, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

/**
 * @brief Sets the child process mode flag
 * Used to determine how to handle signals
 *
 * @param in_child 1 if in child process, 0 otherwise
 */
void	set_child_mode(int in_child)
{
	g_in_child = in_child;
}

/**
 * @brief Sets up signal handlers for interactive mode
 * SIGINT (CTRL+C) is handled by printing a newline and new prompt
 * SIGQUIT (CTRL+\) is ignored
 */
void	setup_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = sig_interactive_handler;
	sa_quit.sa_handler = SIG_IGN;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}

/**
 * @brief Resets signal handlers for child processes
 * SIGINT and SIGQUIT are set to their default behavior
 * This ensures that child processes receive signals normally
 */
void	reset_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = SIG_DFL;
	sa_quit.sa_handler = SIG_DFL;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}

/**
 * @brief Special signal handler setup for the parent process when executing
 * commands
 * This temporarily disables the interactive handler so signals propagate to
 * children
 */
void	setup_parent_signals(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sigemptyset(&sa_quit.sa_mask);
	sa_int.sa_flags = 0;
	sa_quit.sa_flags = 0;
	sa_int.sa_handler = SIG_IGN;
	sa_quit.sa_handler = SIG_IGN;
	sigaction(SIGINT, &sa_int, NULL);
	sigaction(SIGQUIT, &sa_quit, NULL);
}
</file>

<file path="src/test/main.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 17:19:32 by maximart          #+#    #+#             */
/*   Updated: 2025/03/18 12:46:40 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

/**
 * @brief Gets a user input with appropriate prompt based on previous status
 *
 * @param prev_status The exit status of the previous command
 * @return char* The input string obtained from readline
 */
static char	*prompted_input(int prev_status) {
  char *rdl_str1;
  char *rdl_str2;
  char *rdl_str3;
  char *input;

  if (prev_status > 0) {
    rdl_str1 = ft_itoa(prev_status);
    rdl_str2 = ft_strjoin("\001\033[33m\002", rdl_str1);
    rdl_str3 = ft_strjoin(rdl_str2, " $ \001\033[0m\002");
    if (!rdl_str3)
      prev_status = -1;
    input = readline(rdl_str3);
    free(rdl_str1);
    free(rdl_str2);
    free(rdl_str3);
  } else
    input = readline("\001\033[32m\002$ \001\033[0m\002");
  return (input);
}

/**
 * @brief Completes the main loop process by executing commands
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 */
static void		main_loop_end(t_ctx *ctx, int prev_status);

/**
 * @brief Main loop that handles input and command processing
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 * @return void* Always returns NULL
 */
static void	*main_loop(t_ctx *ctx, int prev_status) {
  char *input;

  input = prompted_input(prev_status);
  if (!input)
    ctx_exit(ctx);
  if (input[0] != '\0')
    add_history(input);
  ctx->tokens = tokenize(input);
  free(input);
  if (!ctx->tokens)
    return (main_loop(ctx, 0));
  ctx->cmd = command_parse(ctx->tokens);
  if (!ctx->cmd) {
    free_all_token(ctx->tokens);
    ctx->tokens = NULL;
    return (main_loop(ctx, 0));
  }
  main_loop_end(ctx, prev_status);
  return (NULL);
}

/**
 * @brief Processes input and executes commands
 *
 * @param ctx Context containing environment and state
 * @param prev_status The previous command's exit status
 */
static void	main_loop_end(t_ctx *ctx, int prev_status) {
  t_bool should_exit;
  int status;

  should_exit = false;
  if (ctx->cmd->args && ctx->cmd->args[0] &&
      ft_strncmp(ctx->cmd->args[0], "exit", __INT_MAX__) == 0) {
    ft_putstr("exit\n");
    status = 0;
    should_exit = true;
  }
  if (!should_exit)
    status = command_execute(ctx);
  if (ctx->cmd)
    free_all_commands(ctx->cmd);
  ctx->cmd = NULL;
  if (ctx->tokens)
    free_all_token(ctx->tokens);
  ctx->tokens = NULL;
  if (status == -1)
    status = prev_status;
  if (!should_exit)
    (void)main_loop(ctx, status);
  else
    ctx_clear(ctx);
}

/**
 * @brief Check if we're running in test mode (non-interactive)
 *
 * @return t_bool true if stdin is not a terminal (piped input)
 */
static t_bool	is_test_mode(void) { return (!isatty(STDIN_FILENO)); }

/**
 * @brief Main entrypoint
 *
 * @param argc Arguments count
 * @param argv Arguments
 * @param envp Environment variables
 * @return int Exit code
 */
int	main(int argc, char **argv, char **envp) {
  t_ctx *ctx;

  ctx = init_ctx(argc, argv, envp);
  setup_signals();
  if (is_test_mode())
    rl_outstream = fopen("/dev/null", "w");
  main_loop(ctx, 0);
  if (is_test_mode() && rl_outstream != NULL && rl_outstream != stdout) {
    fclose(rl_outstream);
  }
  ctx_clear(ctx);
  return (EXIT_SUCCESS);
}
</file>

<file path="src/validation/validation.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 15:39:38 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 15:49:51 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "validation.h"

/**
 * @brief Validates that the input string is not too long
 *
 * @param input The input string to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_input_length(char *input, t_ctx *ctx)
{
	size_t	len;

	(void)ctx;
	if (!input)
		return (false);
	len = ft_strlen(input);
	if (len > MAX_INPUT_LEN)
	{
		error_print(ERROR, "input", "Input exceeds maximum length");
		return (false);
	}
	return (true);
}

static t_bool	is_valid_env_name(const char *name)
{
	if (!name || !name[0])
	{
		error_print(ERROR, "env", "Empty variable name");
		return (false);
	}
	if (!ft_isalpha(name[0]) && name[0] != '_')
	{
		error_print(ERROR, "env", "Variable name must start with letter or _");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates that an environment variable name is valid
 *
 * @param name The variable name to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_env_var_name(char *name, t_ctx *ctx)
{
	int	i;

	(void)ctx;
	if (!is_valid_env_name(name))
		return (false);
	i = 1;
	while (name[i])
	{
		if (!ft_isalnum(name[i]) && name[i] != '_')
		{
			error_print(ERROR, "env", "Invalid character in variable name");
			return (false);
		}
		i++;
	}
	if (ft_strlen(name) > MAX_VAR_NAME_LEN)
	{
		error_print(ERROR, "env", "Variable name too long");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates a filename for redirections
 *
 * @param filename The filename to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_filename(char *filename, t_ctx *ctx)
{
	(void)ctx;
	if (!filename || !filename[0])
	{
		error_print(ERROR, "redir", "Empty filename");
		return (false);
	}
	if (ft_strlen(filename) > 255)
	{
		error_print(ERROR, "redir", "Filename too long");
		return (false);
	}
	return (true);
}

/**
 * @brief Validates a full command structure
 *
 * @param cmd The command to validate
 * @param ctx Context for error handling
 * @return t_bool true if valid, false if invalid
 */
t_bool	validate_command(t_command *cmd, t_ctx *ctx)
{
	t_redirection	*redir;

	if (!cmd)
		return (false);
	redir = cmd->redirection;
	while (redir)
	{
		if (!validate_filename(redir->filename, ctx))
			return (false);
		redir = redir->next;
	}
	return (true);
}
</file>

<file path="src/main_utils.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 17:47:37 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/17 17:50:46 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "error.h"
#include "minishell.h"
#include "validation.h"

/**
 * @brief Creates a prompt string based on previous command status
 *
 * @param prev_status Exit status of previous command
 * @return Formatted prompt string
 */
char	*create_prompt(int prev_status)
{
	char	*rdl_str1;
	char	*rdl_str2;
	char	*rdl_str3;
	char	*prompt;

	prompt = NULL;
	if (prev_status > 0)
	{
		rdl_str1 = ft_itoa(prev_status);
		if (!rdl_str1)
			return (NULL);
		rdl_str2 = ft_strjoin("\001" RED "\002", rdl_str1);
		free(rdl_str1);
		if (!rdl_str2)
			return (NULL);
		rdl_str3 = ft_strjoin(rdl_str2, " $ \001" RESET "\002");
		free(rdl_str2);
		prompt = rdl_str3;
	}
	else
		prompt = ft_strdup("\001" GREEN "\002$ \001" RESET "\002");
	return (prompt);
}

/**
 * @brief Gets user input with appropriate prompt
 *
 * @param ctx Shell context
 * @param prev_status Exit status of previous command
 * @return User input string or NULL on error/EOF
 */
char	*get_user_input(t_ctx *ctx, int prev_status)
{
	char	*prompt;
	char	*input;

	prompt = create_prompt(prev_status);
	if (!prompt)
		error_exit(ctx, ERR_ALLOC, "prompt");
	input = readline(prompt);
	free(prompt);
	if (!input)
	{
		ft_putstr("exit\n");
		return (NULL);
	}
	if (input[0] != '\0')
		add_history(input);
	if (!validate_input_length(input, ctx))
	{
		free(input);
		return (NULL);
	}
	return (input);
}
</file>

<file path="src/main.c">
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elagouch <elagouch@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 18:10:00 by elagouch          #+#    #+#             */
/*   Updated: 2025/03/19 18:35:19 by elagouch         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"
#include "error.h"
#include "minishell.h"
#include "validation.h"

/**
 * @brief Processes a command after parsing
 *
 * @param ctx Shell context
 * @param prev_status Previous command exit status
 * @return Exit status of the command
 */
static int	process_command(t_ctx *ctx, int prev_status)
{
	int	status;

	status = prev_status;
	if (ctx->cmd && ctx->cmd->args && ctx->cmd->args[0]
		&& ft_strncmp(ctx->cmd->args[0], "exit", __INT_MAX__) == 0)
		ft_putstr("exit\n");
	status = command_execute(ctx);
	if (ctx->cmd)
		free_all_commands(ctx->cmd);
	ctx->cmd = NULL;
	if (ctx->tokens)
		free_all_token(ctx->tokens);
	ctx->tokens = NULL;
	if (status == -1)
		status = prev_status;
	if (!ctx->exit_requested)
		ctx->exit_status = status;
	return (status);
}

/**
 * @brief Tokenizes and parses user input
 *
 * @param ctx Shell context
 * @param input User input string
 * @return true if successful, false on error
 */
static t_bool	parse_user_input(t_ctx *ctx, char *input)
{
	ctx->tokens = tokenize(ctx, input);
	if (g_debug_level > INFO)
		print_tokens(ctx->tokens);
	free(input);
	if (!ctx->tokens)
		return (false);
	debug_print_tokens(DEBUG_VERBOSE, ctx->tokens);
	ctx->cmd = command_parse(ctx, ctx->tokens);
	if (!ctx->cmd)
	{
		free_all_token(ctx->tokens);
		ctx->tokens = NULL;
		return (false);
	}
	debug_print_commands(DEBUG_VERBOSE, ctx->cmd);
	if (!validate_command(ctx->cmd, ctx))
	{
		free_all_token(ctx->tokens);
		ctx->tokens = NULL;
		free_all_commands(ctx->cmd);
		ctx->cmd = NULL;
		return (false);
	}
	return (true);
}

/**
 * @brief Main command loop for the shell
 *
 * @param ctx Shell context
 * @param prev_status Previous command exit status
 */
static void	command_loop(t_ctx *ctx, int prev_status)
{
	char	*input;
	int		status;
	int		running;

	status = prev_status;
	running = 1;
	while (running)
	{
		input = get_user_input(ctx, status);
		if (!input)
			ctx_exit(ctx);
		debug_log(DEBUG_INFO, "main", "Processing user input");
		if (parse_user_input(ctx, input))
			status = process_command(ctx, status);
		if (ctx->exit_requested)
			running = 0;
	}
}

/**
 * @brief Checks command line args for debug flags
 *
 * @param argc Argument count
 * @param argv Argument values
 */
static void	check_debug_args(int argc, char **argv)
{
	int	i;

	i = 1;
	while (i < argc)
	{
		if (ft_strncmp(argv[i], "--debug", ft_strlen("--debug")) == 0)
			debug_init(DEBUG_INFO);
		else if (ft_strncmp(argv[i], "--verbose", ft_strlen("--verbose")) == 0)
			debug_init(DEBUG_VERBOSE);
		i++;
	}
}

/**
 * @brief Main entrypoint for the minishell program
 *
 * @param argc Argument count
 * @param argv Argument values
 * @param envp Environment variables array
 * @return int Exit status
 */
int	main(int argc, char **argv, char **envp)
{
	t_ctx	*ctx;

	check_debug_args(argc, argv);
	debug_log(DEBUG_INFO, "main", "Initializing minishell");
	ctx = init_ctx(argc, argv, envp);
	if (!ctx)
		error_exit(NULL, ERR_ALLOC, "context initialization");
	setup_signals();
	debug_log(DEBUG_INFO, "main", "Starting command loop");
	command_loop(ctx, 0);
	ctx_clear(ctx);
	return (EXIT_SUCCESS);
}
</file>

<file path=".editorconfig">
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[{*.{c,h},Makefile}]
indent_style = tab
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
</file>

<file path=".gitignore">
*.o
*.d
.idea/
minishell
minishell_test
testb
repomix-output.txt
file_*.txt
output.txt\\nHeredoc
actual_output.txt
.vscode
</file>

<file path=".gitmodules">
[submodule "libft"]
	path = libft
	url = https://github.com/Manomania/libft
</file>

<file path=".repomixignore">
test*.sh
Makefile
*.mk
*.md
libft/*
</file>

<file path="readline.supp">
{
   Readline_All_Functions
   Memcheck:Leak
   ...
   obj:*/libreadline.so*
}
</file>

</files>
